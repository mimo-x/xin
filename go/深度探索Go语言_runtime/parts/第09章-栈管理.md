第 9 章
栈
现代的计算机组成基本上是基于栈的，从单片机到服务器多核心处理器，都是按照栈的思想来设计
的，各种常用的编程语言也是如此。从Go语言的角度来看，goroutine的栈以栈帧的形式提供了函
数局部变量的存储空间，又为函数调用时参数和返回值的传递提供了载体。考虑到函数调用与返回
本身类似于入栈出栈的操作，因此栈是最适合的数据结构。下面，我们就来看一看runtime是如何
管理goroutine的栈的。

9.1 栈分配
栈分配要研究的是goroutine的栈是何时被分配的，以及是怎样进行分配的。首先，要说何时被分
配，当然是在goroutine被创建的时候。在第 6 章分析goroutine创建过程的时候，我们知道
newproc1（）函数会先尝试通过调用gfget（）函数获取一个空闲的g，如果无法获取，就调用malg
来分配一个全新的g。

gfget（）函数从空闲链表中获取的g可能带有栈，也可能不带栈，因为goroutine退出运行的时候，
如果栈的大小不等于初始大小（增长过），就会被释放，因此，gfget（）函数需要检测得到的g有
没有栈，并为不带栈的g分配一个初始的栈。至于malg（）函数，因为是全新分配的g，所以肯定需
要为它分配一个栈。

通过runtime源码可以得知，gfget（）函数和malg（）函数中分配的栈大小都是2KB。至于具体的
栈空间分配工作，是由stackalloc（）函数来完成的。分配细节还得从runtime的初始化说起。

9.1.1 栈分配初始化
经过第 6 章的分析，我们已经知道整个初始化过程由schedinit（）函数负责，其中与栈相关的初始
化是通过stackinit（）函数完成的。stackinit（）函数会初始化两个用于栈分配的全局对象，一个是
栈缓冲池stackpool，另一个是专门用来分配大栈的stackLarge。其中stackpool的定义代码如下：

在Linux环境下，_NumStackOrders的值为 4 ，也就是说stackpool实际上是一个长度为 4 的数组。数组
元素类型是一个结构体，结构体中包含一个stackpoolItem类型的item字段和用于内存对齐的填充空
间。填充空间的作用是把整个结构体的大小对齐到平台Cache Line的大小，以便最大限度地优化存
取速度，因为与逻辑不相关，这里就省略掉了。stackpoolItem结构的定义代码如下：

其中mSpanList是一个由mspan构成的双向链表，mutex用来保护这个链表，真正的栈内存由链表中
的mspan来提供。stackpool的结构如图9-1所示。

图9-1 stackpool结构示意图

stackpool数组的 4 个链表分别用来分配大小为2KB、4KB、8KB和16KB的栈，更大的栈空间由
stackLarge来分配。stackLarge的定义代码如下：

在amd64架构的Linux环境下，heapAddrBits的值是 48 ，pageShift的值是 13 ，所以free字段就是个长
度为 25 的mSpanList数组。下标为 0 的链表对应_PageSize，用来分配8KB的空间，后续依次翻倍，如
图9-2所示。

图9-2 stackLarge结构示意图

由于在实际运行中对大于16KB的栈需求较少，所以这些针对不同大小的链表共用一把锁就可以
了。像stackpool则不然，因为使用频率较高，所以要为每个链表配一把锁。

stackinit（）函数只是校验了_StackCacheSize必须被定义为_PageSize的整倍数，并把stackpool和
stackLarge中的链表都初始化为空链表，函数的代码如下：

目前_StackCacheSize被定义为 32768 ，而_PageSize则是 8192 。接下来可以看一看stackalloc（）函数
是如何分配空间的。

9.1.2 栈分配逻辑
负责分配栈空间的stackalloc（）函数的原型如下：

参数n表示要分配的栈空间的大小，它必须是 2 的幂。返回的stack结构用来表示分配的栈空间，hi字
段是高地址，也就是栈空间的上界，lo表示空间下界，代码如下：

stackalloc（）函数内部会对小于32KB的分配和32KB及以上的分配区分处理，我们先来看一下小于
32KB时的处理逻辑。

1 ．小于 32KB 的栈分配

由于参数n必须是 2 的幂，所以也就是针对16KB及以下的分配。主要的处理逻辑的代码如下：

开始的for循环让order＝log2（n/_FixedStack），在Linux上，_FixedStack被定义为2KB，所以参数n
＝2KB时order为 0 ，n＝4KB时order为 1 ，以此类推，8KB对应 2 ，16KB对应 3 。在后续的分配过程
中，order对应stackcache和stackpool数组的下标。

接下来的if语句会优先使用当前P的mcache中的stackcache进行分配，它是个数组，大小与stackpool
相同，也是_NumStackOrders。实际上就是stackpool的一个本地缓存，不用加锁，效率更高。

不过，有几种情况不能使用stackcache，stackNoCache不为 0 时，表示runtime构建的时候关闭了
stackcache，当前M没有绑定的P时自然无法使用，还有就是GC正在运行的时候，即m.preemptoff不
为空时，会存在并发问题。stackcache数组元素的类型是结构体，具体的定义代码如下：

gclinkptr专门用来构造内存块链表，它会把每个节点最初的一个指针大小的内存用作指向下一个节
点的指针。因为最小的栈也有2KB，所以list字段可以很安全地基于gclinkptr把它们连成一个链表，
size字段记录的是链表的长度。当本地stackcache中某个链表空了的时候，stackcacherefill（）函数
会循环调用stackpoolalloc（）函数从stackpool中对应的链表中取一些节点过来，不是按个数，而是
按照空间大小为_StackCacheSize的一半，也就是每次16KB。

在不能使用stackcache来分配的时候，stackalloc（）函数会直接调用stackpoolalloc（）函数在
stackpool中分配。stackpoolalloc（）函数的主要代码如下：

先尝试从stackpool中取得与目标大小对应的链表，如果链表为空，就从堆上分配一个大小等于
_StackCacheSize的mspan，手动将其划分成目标大小的内存块，添加到manualFreeList中，然后把新
的mspan添加到stackpool对应的链表中。最终的栈是从mspan中分配的，实际上就是从
manualFreeList中取出一个内存块，并增加allocCount计数，如果mspan已经没有剩余空间了，就把
它从stackpool中移除。

上述是16KB及以下大小的栈分配，主要逻辑如图9-3所示。

2 ．大于或等于 32KB 的栈分配

32KB及以上大小的栈分配的主要代码如下：

通过把参数n右移_PageShift位，计算出整页面数npage。再通过stacklog2用npage对 2 做对数运算，得
到log2npage用作stackLarge.free数组的下标，从对应的链表中取出一个mspan。如果链表为空，就从
堆上分配一个大小为npage个页面的mpan。最后，把mspan中的所有内存用作栈，分配工作就完成
了。

图9-3 16KB及以下大小的栈分配
3 ．栈分配逻辑总结

我们总结一下整个分配逻辑，如果栈大小小于32KB，就从stackpool中分配。首先尝试本地缓存
p.mcache.stackcache，缓存若为空就调用stackcacherefill（）函数从stackpool中分配16KB空间放入本
地缓存。如果不能使用本地缓存，就调用stackpoolalloc（）函数直接从stackpool中分配。
stackpoolalloc（）函数会按需从堆中分配32KB的内存，并划分成目标大小的块，添加到stackpool对
应的链表中。如果栈大小大于或等于32KB，先检查一下stackLarge对应的链表中有没有，如果没有
就直接堆分配。

goroutine栈的初始分配都发生在创建阶段，由gfget（）函数或malg（）函数调用stackalloc（）函数
分配一个最小的栈，但是stackalloc（）函数并不只是在这里被调用，在运行阶段栈空间需要增长的
时候，会调用该函数重新分配更大的栈空间，这也是9.2节中要研究的内容。

9.2 栈增长
在复杂的业务逻辑中，函数调用层级往往也会很深，栈空间会随着函数调用层级的加深而不断消
耗。初始的2KB栈空间很可能会不够用，所以需要实现一种运行阶段动态增长的机制。goroutine的
栈增长是通过编译器和runtime合作实现的，编译器会在函数的头部安插检测代码，检查当前剩余
的栈空间是否够用，在不够用的时候调用runtime中的相关函数来增长栈空间。

9.2.1 栈增长检测代码
本书至此，我们已不止一次见到过栈增长检测代码，笔者多次给出对应的伪代码如下：
其实这只是几种检测代码中的一种，根据runtime源码可以得知，编译器安插在函数头部的栈增长
检测代码一共有 3 种形式，根据当前函数栈帧的大小来确定选用哪一种，接下来我们就逐个来看一
下。

1 ．第一种形式的栈增长检测

第一种栈增长检测形式针对函数栈帧大小不超过_StackSmall（ 128 字节）时，属于较小栈帧的情
况。只要栈指针SP的位置没有超过stackguard0的界限，就不用进行栈增长。也就是说，在
stackguard0以下有 128 字节空间可供安全使用。检测代码直接比较栈指针SP和stackguard0，代码如
下：

我们可以通过反编译一个栈帧为 128 字节的函数来实际验证一下，在amd64+Linux环境下编译一个
示例，代码如下：

函数的逻辑并不重要，有两点需要简单说明一下：
（ 1 ）noinline注释用来避免函数被编译器内联优化掉，那样就不能反编译了。

（ 2 ）声明一个 104 字节的数组b，使上述函数的栈帧正好凑足 128 字节，函数栈帧的分配如图9-4所
示。

图9-4 示例函数栈帧布局
反编译之后，汇编代码的一头一尾就是栈增长检测代码，汇编代码如下：
第一条指令MOVQ把当前协程g的地址放到CX寄存器中，加上 16 字节偏移就是stackguard0字段的地
址，第二条指令CMPQ直接比较stackguard0和栈指针寄存器SP。第四条指令ADDQ把栈指针向下移
动了0x80字节，对应 128 字节的栈帧大小。用伪代码来描述上述的栈增长检测逻辑就是我们之前多
次见过的这种形式，伪代码如下：

2 ．第二种形式的检测代码

接下来再看一看第二种形式的检测代码，源码注释中说，当函数栈帧大小大于_StackSmall并且小
于_StackBig的时候，会采用第二种形式的检测代码。根据笔者的测试，在栈帧大小等于_StackBig
的时候也会采用这种形式，所以正确的范围应该是在栈帧大于 128 字节，并且不超过 4096 字节的时
候。我们把上述test（）函数中数组b的大小改成 4072 ，这样就能够构造一个 4096 字节的栈帧，再次
反编译之后得到的检测代码如下：

第二条指令LEAQ用SP减去 3968 ，把结果放到了AX寄存器中。第三条指令CMPQ把AX寄存器的值
和stackguard0进行比较。这里的 3968 是由栈帧大小减去_StackSmall得到的，如图9-5所示。

图9-5 第二种形式示例函数栈帧布局
整个检测逻辑对应的伪代码如下：
减去_StackSmall是因为stackguard0以下 128 字节是可以安全使用的，此范围以内不用进行栈增长。
在framesize小于或等于_StackSmall的时候，括号内部是 0 或一个负数，SP减去它相当于加上一个非
负数。只要SP大于stackguard0，加上一个小于 128 的非负数肯定也会大于stackguard0，所以第一种
形式的检测代码可以看作第二种的简化版本。

3 ．第三种形式的检测代码

第三种形式的检测代码，也是最后一种，在函数栈帧大小超过 4096 字节时，会使用这种形式。还是
基于test（）函数，我们把数组b的大小改成 4080 ，这样栈帧大小就变成了 4104 。反编译之后得到的
汇编代码如下：

此处省略掉了函数逻辑，只保留了栈增长代码。第三条指令中的-0x522对应常量stackPreempt，第
五条指令中的0x3a0对应常量_StackGuard，而第七条指令中的0x1328是由栈帧大小0x1008加上
_StackGuard再减去_StackSmall后得到的。这次的检测逻辑比之前的两种要复杂一点，转换成伪代
码如下：

SP和stackguard0都是无符号整型，因为内存地址不存在负数，相应的大小比较也是针对无符号整型
的，JBE是无符号比较对应的跳转指令。无符号整型运算需要格外注意Wrap Around问题（环回问
题），也就是一个数减去比自己大一些的数，会得到一个极大的正数，因此，要在两侧都加上
_StackGuard，避免因为SP小于stackguard0造成减法结果环回。_StackGuard表示stackguard0到栈底
的距离，在Linux下是 928 字节，SP加_StackGuard肯定大于stackguard0。

如图9-6所示，如果将两侧的变量进行移动，并且消除_StackGuard，就会发现和第二种形式是等价
的，只不过这种变形后的比较不兼容stackPreempt，所以要前置单独判断。

图9-6 第 3 种形式示例函数栈帧布局
至此，编译器安插的三种形式的栈增长检测代码都讲解过了，本质上都是判断栈指针SP向下移动
栈帧大小framesize字节以后，不会超过stackguard0以下_StackSmall的位置。第三种形式最为接近，
其他两种形式分别是在此基础上的简化和变形。

看完了编译器安插的代码，接下来研究一下runtime中用来执行栈增长的函数。

9.2.2 栈增长函数
通过9.2.1节的反汇编可以发现，负责进行栈增长的是runtime.morestack_noctxt（）函数，该函数是
用汇编语言实现的，代码如下：

它只不过是把DX寄存器清零，然后跳转到runtime.morestack（）函数。noctxt是no context的缩写，
指的是没有闭包上下文。在第 3 章讲解Function Value的时候我们已经知道，背后可能是个闭包，也
可能是个普通的函数，Go统一支持它们，而栈增长会区分闭包和普通的函数，它们各自会调用不
同的函数进行栈增长。

首先，我们准备一个闭包函数，代码如下：

反编译的时候需要指定内部闭包函数，对于这种匿名的函数，Go的反编译工具会对它们进行编
号。例如这里是mc（）函数里的第 1 个匿名函数，名字是mc.func1。反编译之后在得到的栈增长代
码中调用的是runtime.morestack（）函数，代码如下：

阶段性总结一下，闭包函数内部如果需要栈增长，会直接调用runtime.morestack（）函数，而一般
的函数会调用runtime.morestack_noctxt（）函数，它会先显式地将DX寄存器清零，然后调用
morestack（）函数。

morestack（）函数也是一个用汇编语言实现的函数，它会先进行一些检查工作，因为不能增长g0
和gsignal的栈，所以它会先把调用者的PC、SP等存入g.sched中，然后调用newstack（）函数来增长
栈。后半部分的代码如下：

需要注意的是newstack（）函数是不会返回的，它的执行流程如图9-7所示。newstack（）函数并不
一定会执行栈增长，在stackguard0等于常量stackPreempt时会调用gopreempt_m（）函数让出CPU。
至于正常的栈增长逻辑，newstack（）函数先把当前的栈空间大小乘以 2 ，并把协程状态置为
_Gcopystack，接下来调用copystack（）函数完成新空间分配及旧栈上数据的复制，最后将协程状
态恢复为_Grunning并通过gogo（&g.sched）来恢复协程运行。

copystack（）函数真正完成了新空间分配和旧数据复制，其中有很多比较重要的细节，接下来就把
最主要的逻辑摘选出来，分段进行分析。

第一部分代码如下：

把当前协程的旧有栈空间范围记录在old中，计算出实际已使用的空间大小并存储在变量used中，
分配新的栈空间new，根据新旧栈空间的栈底做减法得出要调整的偏移量。

第二部分代码如下：

图9-7 newstack（）函数执行流程

ncopy是接下来要复制的栈区间大小，默认等于已经使用的区间大小used。activeStackChans表明存
在未加锁的channel指向正在被移动的栈，需要先对这些channel加锁，然后才能安全地对栈进行操
作。当newsize小于旧有栈空间大小时，表明在进行栈收缩操作，而parkingOnChan表示当前协程正
在等待channel通信，此时不允许进行栈收缩，但是可以进行增长。adjustsudogs（）函数用来调整
当前协程的waiting链表，它会把每个sudog节点的elem指针都加上delta偏移量，使它们都指向新的
栈空间，如图9-8所示。

图9-8 栈增长时waiting链表调整示意图

findsghi（）函数会遍历当前协程的waiting链表，找出所有sudog的elem指针中值最大的那个。因为
栈是向下增长的，如果协程因为channel通信而发生等待，则channel一般会指向最近的栈帧，所以
对于从栈顶到sghi的这段区间必须谨慎操作。

syncadjustsudogs（）函数会对所有的channel加锁，然后调用adjustsudogs（）函数对waiting链表中
的sudog进行调整，并通过memmove（）函数复制栈顶到sghi这段区间的栈内存，最后释放所有
channel的锁，并返回复制的栈区间的大小。ncopy中要减去syncadjustsudogs已经复制的区间大小，
剩下的栈内存就可以不用加锁了，可直接通过memmove（）函数进行复制。

第三部分代码如下：

adjustctxt（）函数负责对闭包上下文进行调整，实际上是把gp.sched.ctxt加上偏移量delta，如果启
用了frame pointer，则该函数也会调整gp.sched.bp。adjustdefers（）函数负责调整gp._defer链表中每
个_defer结构的各个字段，以及后面追加的函数参数。adjustpanics（）函数主要用于调整
gp._panic，使它指向新的栈。

第四部分代码如下：

使用新的栈空间new替换掉旧的栈空间，并更新stackguard0、sched.sp和stktopsp，让它们指向新的
栈空间。通过gentraceback（）函数回调adjustframe（）函数，对新栈上的地址类变量进行修正。
adjustframe（）函数会调用adjustpointers（）函数，后者在修改栈上的指针时对于栈顶到sghi这段区
间内的指针会使用CAS操作以保证安全。最后通过stackfree（）函数释放旧的栈，这样
copystack（）函数就完成任务了。

9.3 栈收缩
在9.2节中分析copystack（）函数源码的时候，我们发现它不仅支持栈增长，也可以执行栈收缩。
就像它的名字一样，copystack（）函数只是复制并移动栈，当newsize比原来的栈空间更小时，实
际上执行的是一次栈收缩。

在runtime中有个专门负责栈收缩的函数，即shrinkstack（）函数。它会进行一些校验，然后用当前
栈大小的一半作为newsize调用copystack（）函数。在runtime中有两个地方会调用shrinkstack（）函
数，一个是在scanstack（）函数中，另一个是在newstack（）函数中。GC的markroot（）函数会调
用scanstack（）函数，scanstack（）函数又会调用shrinkstack（）函数，代码如下：

如果当前能够安全地执行栈收缩，则scanstack（）函数就会直接调用shrinkstack（）函数，否则就
设置preemptShrink标识。在newstack（）函数中检测到stackPreempt之后，在让出CPU之前还会检查
preemptShrink，如果值为true就会先进行栈收缩，代码如下：

也就是说，唯一发起栈收缩的地方是GC的scanstack（）函数。如果安全就会立即进行栈收缩，否
则就设置preemptShrink标识，等到newstack（）函数检测到该标志再调用shrinkstack（）函数收缩
栈。整体来看，newstack（）函数的名字也是很有道理的，因为它既可以执行栈增长，也可以执行
栈收缩。

最后还有一点比较重要，需要分析一下，也就是在什么情况下能够安全地执行栈收缩，这就要看一
看isShrinkStackSafe（）的源码，代码如下：

首先判断gp.syscallsp是否等于 0 ，如果gp.syscallsp等于 0 ，则说明当前没有在执行系统调用，系统调
用可能会有一些指针指向协程的栈，并且很多参数经过强制类型转换，无法得到最内层栈帧精确的
指针位图。其次要判断asyncSafePoint是否等于false，如果asyncSafePoint等于true，则表明当前协程
处在异步抢占中，这种情况下也无法得到最内层栈帧精确的指针位图。最后通过原子性的Load操
作判断parkingOnChan是否等于 0 ，在parkingOnChan不等于 0 的时候，表示协程正在调用gopark（）
函数在某个channel上挂起等待，但是还没设置activeStackChans的值，在这个时间窗口内也不能执
行栈收缩，因为copystack（）函数依赖activeStackChans的值来决定是否需要加锁，在这个时间窗
口内会出现错误。

9.4 栈释放
本节我们来关注一下栈空间的释放，主要指的是goroutine的栈，在什么时候及是如何被回收的。通
过源码来分析比较容易找到用来释放栈空间的函数。与分配栈空间的stackalloc（）函数对应，
stackfree（）函数用来释放栈空间。通过stackfree（）函数的源码，我们基本上能了解栈空间是如
何被释放的，再通过分析对stackfree（）函数的引用，就能知道栈空间是何时被释放的。

stackfree（）函数的处理逻辑和stackalloc（）函数是对应的，也是把16KB及以下和32KB及以上的
栈空间分开处理的。

9.4.1 小于或等于 16KB 的栈空间
我们先来看一看不超过16KB的栈是如何被回收的，主要逻辑代码如下：
同样先计算出log2（n/_FixedStack）并赋值给order，如果当前可以操作stackcache，就把要释放的栈
内存放到stackcache对应的链表中，提前检测对应链表中空间总大小是否达到或超过了32KB，通过
stackcacherelease（）函数把多余的内存放回到stackpool中，只保留_StackCacheSize的一半，也就是
16KB。如果当前不能操作stackcache，就直接调用stackpoolfree（）函数，把要释放的内存直接放
到stackpool对应的链表中。stackpoolfree（）函数释放后会检查对应的mspan是否完全空闲，并调用
堆释放函数把完全空闲的mspan释放。

9.4.2 大于或等于 32KB 的栈空间
针对32KB及以上大小的栈空间释放的相关代码如下：
先通过栈空间的起始地址（低地址）找到对应的mspan，如果当前处于GC的清理阶段，就直接调用
堆释放函数释放该mspan。若GC正在运行，为了避免栈空间被重用发生冲突，就先把它放入
stackLarge的free链表中。

stackfree（）函数的逻辑到这里就梳理完了，那么该函数何时会被调用呢？

9.4.3 栈释放时机
通过分析源码中的调用关系，笔者发现会有两个地方调用该函数来释放常规goroutine的栈。常规
goroutine，指的是除了g0、gsignal这类特殊协程之外，那些通过newproc（）函数创建的goroutine。
这两处调用stackfree（）函数的地方，一处是在gfput（）函数中，代码如下：

如图9-9所示，该逻辑把大小不等于_FixedStack的栈都释放，这个大小也正是初始分配时的栈大
小，因为shrinkstack（）函数不会把栈收缩到比这更小，所以该逻辑是把所有增长过的栈都释放，
其目的是节省内存空间。

另一处调用stackfree（）来释放常规goroutine栈空间的地方在markrootFreeGStacks（）函数中，这
个函数整体不算复杂，具体代码如下：

图9-9 常规栈释放的第 1 个时机gfput

在锁的保护下，首先获取sched.gFree.stack链表并存到本地变量list中，sched.gFree.stack就是有栈的
那个全局空闲g链表。获取链表后把原链表清空，遍历获取的链表list，调用stackfree（）函数逐个
释放栈，然后将gp.stack清零并把gp放入队列q中。最后把队列q全部push到sched.gFree.noStack中，
也就是没有栈的那个全局空闲g链表，主要逻辑如图9-10所示。

图9-10 常规栈释放的第 2 个时机markrootFreeGStacks

进一步追踪markrootFreeGStacks（）函数的调用者，发现只有一个地方会调用它，即markroot（）
函数，也就是说源头是GC，所以常规goroutine栈的释放，一是发生在协程运行结束时，gfput会把
增长过的栈释放，栈没有增长过的g会被放入sched.gFree.stack中；二是GC会处理sched.gFree.stack
链表，把这里面所有g的栈都释放，然后把它们放入sched.gFree.noStack链表中。

9.5 本章小结
至此，关于goroutine栈内存管理的探索就告一段落了。我们了解了栈空间是如何分配与释放的，几
个关键词是stackcache、stackpool和stackLarge。还知道了newstack（）函数既能进行栈增长，又能
进行栈收缩，shrinkstack（）函数只负责栈收缩，这两者都是基于copystack（）函数实现的。
copystack（）函数会分配新的栈空间，复制旧的栈数据并通过一系列adjustxxx（）函数进行指针修
正，最后释放旧的栈空间。GC会发起栈收缩，以及释放sched.gFree.stack中所有g的栈空间。

考虑到栈增长的复杂性，应该还是有一定开销的，因此，对于栈深度较大的逻辑，应该避免频繁地
创建和销毁协程，可以尝试结合有缓冲channel实现一个简单的协程池。

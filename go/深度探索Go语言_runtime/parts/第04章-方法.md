第 4 章
方法
Go语言支持面向对象思想，提供了type关键字，可以用来自定义类型，并且可以为自定义类型实现
方法。下面定义一个Point类型，代码如下：

Point表示一维坐标系内的一个点，并且按照Go语言的风格为其实现了一个Getter方法和一个Setter
方法。本章后续内容将会以Point类型为研究对象，展开与方法相关的问题的探索。

从语法角度来看，Go语言的方法并不像C++、Java中class的方法那样包含在type定义的语句块内，
而是像普通函数一样直接定义在package层，只不过多了一个接收者。以Point类型的两种方法为
例，处在func关键字和方法名之间的，就是方法的接收者，它看起来就像一个额外的参数。

4.1 接收者类型
在第 3 章中已经探索过普通函数的调用约定，了解了参数和返回值是通过栈传递的，这里就会比较
好奇方法接收者的传递方式：到底是像一般参数那样通过栈传递，还是像C++的thiscall那样使用某
个指定的寄存器？

通过反编译很容易验证。为了排除编译器内联优化造成的干扰，下面采用只编译不链接的方式来得
到OBJ文件，然后对编译得到的OBJ文件进行反编译分析，编译命令如下：

上述命令禁用了内联优化，编译完成后会在当前工作目录生成一个point.o文件，这就是我们想要的
OBJ文件。通过go tool nm可以查看该文件中实现了哪些函数，nm会输出OBJ文件中定义或使用到
的符号信息，通过grep命令过滤代码段符号对应的T标识，即可查看文件中实现的函数，执行命令
如下：

可以看到point.o中一共实现了 3 个方法，它们都定义在Point类型所在的gom包中。第 1 个是Point的
SetX（）方法，它的接收者类型是Point，第 3 个是Point的X（）方法，它的接收者类型是Point，
这些都与源代码一致。比较奇怪的是第二个方法，这是一个接收者类型为Point的X（）方法，源
代码中并没有这个方法，它是怎么来的呢？只能是由编译器生成的。那么编译器为什么要生成它
呢？这就需要循序渐进地进行探索了。

为了方便描述，我们将接收者类型为值类型的方法称为值接收者方法，将接收者类型为指针类型的
方法称为指针接收者方法。接下来先通过反编译的方式看一下，这两种接收者参数都是如何传递
的。

4.1.1 值类型
先来看一下Point类型中的值接收者方法X（），反编译后得到的汇编代码如下：

因为函数过于简单，对栈空间也没有太大消耗，所以编译器没有插入与栈增长相关的代码，也没有
通过SUB指令移动SP来为方法X（）分配栈帧，所以SP指向的是CALL指令压入栈中的返回地址。
第 4 行代码用SP作为基址并加上 8 字节偏移，把该地址处的一个float64复制到X0寄存器中。

第 5 行代码用SP作为基址并加上 16 字节偏移，把X0中的float64复制到该地址处。

第 6 行代码就是普通的返回指令。

按照上述汇编代码逻辑，栈上的布局如图4-1所示。

图4-1 调用Point.X（）方法后的栈帧布局

结合方法X（）的源代码，栈指针SP加 16 字节偏移处，应该就是函数的返回值。SP加 8 字节偏移
处，应该就是函数第 1 个参数的位置。从代码逻辑来看，这个参数存储的就是p.x的值，而Point类型
只有x这一个成员，所以第 1 个参数是p的值。这就说明值类型的接收者实际上是作为第 1 个参数通过
栈来传递的，与普通的函数调用并没有什么不同。

Go语言允许通过方法的完全限定名称（Full Qualified Name）把方法当成一个普通函数那样调用，
只不过需要把接收者作为第 1 个参数显式地传递，示例代码如下：

可以认为p.X（）这种写法只是编译器提供的语法糖，本质上会被转换为Point.X（p）这种普通的
函数调用，而接收者就是隐含的第 1 个参数。

4.1.2 指针类型
4.1.1节分析了值接收者参数的传递方式，本节再来看一下指针类型接收者的参数传递方式。还是通
过反编译的方式，这次要反编译SetX（）方法，反编译后得到的汇编代码如下：

跟之前一样，因为函数很简单，所以既没有插入与栈增长相关的代码，也没有移动SP来分配栈
帧，SP指向栈上的返回地址。
第 4 行代码用SP作为基址加上 16 字节偏移，把该地址处的一个float64复制到X0寄存器中。

第 5 行代码用SP作为基址加上 8 字节偏移，把该地址处的一个 64 位数值复制到AX寄存器中。

第 6 行代码用AX作为基址，把X0寄存器中的float64复制到该地址处。

第 8 行是返回指令。

按照上述汇编代码逻辑，画出栈上的布局如图4-2所示。

图4-2 调用Point.SetX（）方法后的栈帧布局

结合SetX（）方法的源码可以推断出，栈指针SP加 16 字节偏移处存储的浮点型数值，就是
SetX（）方法的参数x。SP加 8 字节偏移处存储的 64 位数值就是接收者p的地址，所以跟值类型接收
者类似，指针类型的接收者也是作为第 1 个参数来传递的，只不过传递的是一个地址。

同值接收者方法一样，也可以通过完全限定名称把指针接收者方法作为一个普通函数那样调用，只
是语法上稍有不同，代码如下：

4.1.3 包装方法
本节开头通过nm查看OBJ文件中的符号的时候，发现OBJ文件中多了一个源码中没有的方法。源码
中X（）方法的接收者是值类型，而OBJ文件中多了一个拥有指针类型接收者的X（）方法。猜测
这种方法应该是编译器根据源代码中原本的X（）方法自动生成的包装方法，通过接收者的地址可
以得到接收者的值，所以反编译来看一下代码逻辑，反编译得到的汇编代码如下：

通过gofile对应的autogenerated可以确定该方法确实是由编译器自动生成的。反编译得到的汇编代码
还是有些复杂，为了便于理解，在保证逻辑一致的前提下，转换后的伪代码如下：

第 1 个if语句块通过比较栈指针SP和gp.stackguard0来判断是否需要栈增长。

第 2 个if用于检测是否正处于panic流程中，这种情况下当前方法应该是被某个defer直接或间接地调
用了，要按需修改gp._panic.argp的值，因为当前方法是编译器自动包装的，通过修改argp来跳过包
装方法的栈帧，使后面调用的原始方法中的recover能够生效。

第 3 个if用于检测p是否为nil，因为包装方法需要根据p的地址得到*p的值，如果地址为nil就调用
runtime.panicwrap。

最后一步才是调用原始的Point.X（）方法并传递*p的值作为参数。

如果不禁用内联优化，则生成的代码会稍微有些不同，但是大致逻辑还是一样的。编译器会为代码
中定义的值接收者方法生成指针接收者的包装方法，这在语义上是可行的，但反过来却不可以，因
为通过传递的值是无法得到原始变量的地址的。

虽然知道了包装方法的大致逻辑，但还是没有搞清楚编译器生成包装方法的原因。如果是为了支持
通过指针直接调用值接收者方法，则直接在调用端进行指针解引用就可以了，总不至于为此生成包
装方法吧？为了验证这个问题，再次准备一个函数用来反编译，函数的代码如下：

大致思路就是通过指针来调用值接收者方法，再通过反编译看一下实际调用的是不是包装方法。反
编译得到的汇编代码如下：
可以看到p.X（）实际上会在调用端对指针解引用，然后调用值接收者方法，并没有调用编译器生
成的包装方法。那这个包装方法有什么用途呢？现在还不能解释，到第 5 章介绍接口时再来回答这
个问题。

4.2 Method Value
第 3 章中探索了Function Value底层的数据结构，实质上可能是个两级指针，也可能是个闭包对象，
要结合具体的上下文才能确定。简单来讲，把一个函数存储在一个变量中，这个变量就是一个
Function Value。相应地，把一个方法存储在一个变量中，这个变量就是个Method Value。那么
Method Value又有着怎样的底层实现呢？与Function Value有什么异同？本节就围绕这些问题展开探
索。

4.2.1 基于类型
可以通过方法的完全限定名称把自定义类型的某个方法赋值给一个变量，这样就会得到一个基于类
型的Method Value，也就是所谓的Method Expression。还是以Point类型为例，定义一个基于类型的
Method Value，示例代码如下：

4.1节已经验证了方法其实就是个普通的函数，接收者是隐含的第 1 个参数，所以这里可以推断，基
于类型的Method Value就是个普通的Function Value，本质上是个两级指针，而且第二级的指针是在
编译阶段静态分配的。

通过示例代码很容易验证上述推断，代码如下：

上述代码可以成功编译，说明Point.X（）函数可以被赋值给func（Point）float64类型的Function
Value。接下来反编译GetX（）函数，得到的汇编代码如下：

第 4 行代码用IP作为基址加上一个偏移 0 来得到一个地址，这个 0 只作为预留的一个 32 位整数，等到
链接阶段，链接器会填写上实际的偏移值。第 4 行代码得到的地址被用作返回值，也就是最终的
Function Value，而该地址处就是第二级指针，从而验证了上述推断。

4.2.2 基于对象
可以把一个对象的某个方法赋值给一个变量，这样就会得到一个基于对象的Method Value，示例代
码如下：

从语义角度来看，与基于类型的Method Value不同，基于对象的Method Value隐式地包含了对象的
数据，所以在上述代码中调用x时不需要再显式地传递接收者参数。第 3 章中已经了解了闭包的实现
原理，所以这里推断x是个指向闭包对象的指针，通过闭包的捕获列表捕获了对象p。

为了验证这种推断，实现一个示例函数，代码如下：
反编译上面的函数，得到的汇编代码如下：
为了便于理解，改写成逻辑等价的伪代码如下：
编译器为返回值自动定义了一个struct，第 1 个成员是一个函数指针，第 2 个成员是一个Point对象。
对应到闭包对象的结构，捕获列表中是Point类型的对象，闭包函数是gom.Point.X-fm（）函数，也
是由编译器自动生成的。下面反编译一下这个闭包函数，得到的汇编代码如下：

等价的伪代码如下：
主要逻辑就是通过DX寄存器得到闭包对象的地址，再以捕获列表里的Point对象的值作为参数调用
Point.X（）方法，并把Point.X（）方法的返回值作为自己的返回值。

进一步探索会发现，闭包是捕获对象的值还是捕获地址，跟Method Value对应的方法接收者类型一
致。上述示例中Point.X（）方法的接收者为值类型，所以闭包捕获的也是值类型，如果换成接收
者为指针类型的*Point.SetX（）方法，闭包捕获列表中就会相应地变成指针类型。

至此可以进行一下总结，基于类型的Method Value和基于对象的Method Value本质上都是Function
Value，只不过前者是简单的两级指针，而后者通常是个闭包（考虑编译器优化）。

4.3 组合式继承
Go语言中提供了一种组合式的继承方式，在语法和思想上都与C++、Java等语言中的继承有些不
同。本节要探索一下编译器是如何支持这种继承方式的。

继续使用Point类型，定义一个Point2d类型来表示二维坐标系内的一个点，采用组合式继承的方式
继承Point类型，代码如下：

接下来的探索将用到这两个类，为了叙述方便，后续内容将继续采用传统的面向对象术语，把
Point称为基类，而Point2d就是Point的子类。

4.3.1 嵌入值
图4-3 Point2d内存布局示意图

在Point2d的类型定义中，Point类型以嵌入值的形式嵌入Point2d中，Point就是Point2d的一个字段，
Point2d类型的内存布局如图4-3所示。

组合式继承也是继承，所以Point2d应该会继承Point的所有方法，可以再次用nm命令查看一下OBJ
文件中为Point2d类型实现了哪些函数和方法，命令如下：

最后一个函数是由编译器自动生成的，用于判断两个Point2d对象是否相等，现阶段不用关心这个
函数。剩下的就是Point2d类型的 6 个方法，其中有 3 个和X相关，另外 3 个和Y相关。和Y相关的这 3
个方法没有什么特殊的，即Point2d类型的方法。和X相关的这 3 个方法，应该就是从Point类型继承
过来的，接下来逐个看一下这 3 个方法的逻辑。

首先反编译一下Point2d.X（）方法，为了节省篇幅，这里不再列出汇编代码，还是用笔者根据汇
编代码整理的等价伪代码来代替，代码如下：

忽略其中编译器插入的栈增长和按需修改gp._panic.argp的代码，这样就只剩下以p.Point为参数来调
用Point.X（）方法的代码，也就说明这是个包装方法，因此可以推测，编译器对于继承来的方法
都是通过生成相应的包装方法来调用原始方法的方式实现的。接下来就通过分析Point2d继承的其
他两个方法来验证。

反编译（*Point2d）.SetX（）方法得到的汇编代码如下：

编译器没有为这个SetX（）方法生成复杂的包装逻辑，只是实现了一个空指针校验和跳转指令。

第 1 条指令把接收者的值复制到AX寄存器中。

第 2 条指令尝试访问AX存储的地址处的数据，如果接收者为空指针就会触发空指针异常。
第 3 条指令把AX的值复制到栈上接收者参数的位置，这一行其实可以优化掉。
第 4 条指令用于跳转到（*Point）.SetX（）方法的起始地址。

为什么可以直接跳转呢？从传参的角度来看就比较好理解了。Point是Point2d的第 1 个字段，所以
Point2d的地址也就等于内嵌的Point的地址，所以可以认为（Point2d）.SetX（）方法和
（Point）.SetX（）方法的参数和返回值无论是内存布局还是逻辑含义都一样，所以直接跳转是没
有问题的。可以认为这是编译器对指针接收者包装方法进行了优化，对于值接收者包装方法则不会
进行这种优化，因为子类一般会对基类进行扩展，在作为值传递的时候内存布局无法保证一致。

最后反编译一下（*Point2d）.X（）方法，对照汇编整理出的伪代码如下：

可以看到除了接收者为指针类型外，代码逻辑与Point2d.X（）方法基本一致，所以嵌入值实现的
组合式继承并没有什么特别的地方，编译器会为继承的方法生成包装方法。实际上，Point和
Point2d的这些方法都很简单，正常情况下都会被编译器内联优化掉。这里先记住编译器是如何生
成这些包装方法的，在后续的章节中会逐渐发现它们的真正用途。

4.3.2 嵌入指针
将Point2d类型定义修改为嵌入*Point类型，即可实现嵌入指针的组合式继承，代码如下：

相应地，Point2d中不再直接包含Point的值，而是包含Point对象的地址。两者在内存中的布局关系
也变得与之前不同，如图4-4所示。

图4-4 Point2d与Point的内存布局关系

再用nm命令查看一下OBJ文件中为Point2d类型实现了哪些函数和方法，命令如下：

这里值得注意的是Point2d.SetX（）方法，它的存在意味着虽然接收者Point2d是通过值的形式传递
的，但是通过Point2d的值可以得到原始Point对象的地址，所以依然可以对原始Point对象进行修
改。

至于其他几个继承的方法，这里就不再一一进行反编译了，只是看一下在嵌入指针的情况下
（*Point2d）.SetX（）方法还会不会被优化处理，代码如下：

编译器还进行了优化处理，第 1 行指令把栈上的接收者参数复制到AX寄存器中，其实也就是
Point2d对象的地址。第 2 行指令把Point2d的第 1 个字段的值复制到AX寄存器中，也就是Point对象的
地址。第 3 行指令把AX的值复制回栈上的接收者参数处。第 4 行指令用于跳转到
（*Point）.SetX（）方法的起始地址。

至于其他 3 种方法，编译器都会生成相应的包装方法，这里不再赘述，直接列出对应的伪代码。为
了使代码更加简洁，这里省略了栈增长和处理gp._panic.argp的相关逻辑，精简后的代码如下：

通过本节的探索可以发现，因为在嵌入指针的情况下总是能够得到基类对象的地址，所以子类中的
值接收者方法可以调用基类中的指针接收者方法，编译器会尽可能把符合逻辑的包装方法都生成出
来。
4.3.3 多重继承
组合式继承之下的多重继承，实际上就是在子类的定义中嵌入多个基类。嵌入的多个基类可以按需
嵌入值或嵌入指针，内存布局方面前两节已经分别给出相应的图示，这里不再赘述。本节主要探索
一下多重继承对编译器生成包装方法会有哪些影响。
首先定义两种类型A和B，分别为它们实现一组相同的方法Value（）和Set（），代码如下：

然后定义一种类型C，将A和B以值的形式嵌入，代码如下：
通过nm命令查看编译生成的OBJ文件中都实现了哪些方法，命令如下：

发现只有A和B的方法，编译器没有为C生成任何方法。结合Go语言官方文档的说明，因为同时嵌
入A和B而且嵌套的层次相同，所以编译器不知道应该让包装方法继承自谁，这种情况只能由程序
员手工实现。

下面再来看一下嵌套层次不同的情况。定义一种类型D，把A以嵌入值的形式嵌入D中，然后把C中
的A改成D，代码如下：

再次通过nm命令查看，命令如下：

这次类型C成功地继承了这一组方法，对这些方法进行反编译就能确定是继承自类型B，因为B的嵌
套层次比A要浅，编译器优先选择短路径。
4.4 本章小结
本章首先探索了方法接收者的传递方式，发现接收者实际上就是编译器隐式传递的第 1 个参数，也
是通过栈传递的，所以方法调用本质上与普通的函数调用是一样的。同时，还发现了编译器会为值
接收者方法生成指针接收者的包装方法，暂时还没有弄清楚这样做的意义，然后又探索了Method
Value的实现原理，发现其本质上依然是Function Value，不过编译器会自动为基于对象的Method
Value生成闭包函数，闭包捕获的类型与方法接收者的类型一致。最后还探索了组合式继承之下编
译器是如何为继承的方法生成包装方法的。

通过了解底层的具体实现，对方法有了更深入的理解，接下来的第 5 章我们将走进Go语言的动态语
言特性。
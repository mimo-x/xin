

第 1 章
汇编基础
20 世纪 90 年代，随着Microsoft Windows系统在世界范围流行，Intel公司的x86架构CPU占据了个人
计算机的主要市场。近十年来，开源的Linux系统日渐成熟完善，伴随着云计算的热潮，各大互联
网巨头纷纷推出了基于x86_64架构的弹性计算服务，x86架构又占据了服务器的主要市场。本章只
简单讲解x86汇编语言的必要基础知识，其目的是为后续研究Go语言的底层特性做好准备。熟悉
x86架构和x86汇编的读者，可以跳过本章直接阅读后续章节。

文中所使用的寄存器名称，以及示例汇编代码都符合Intel汇编风格，与Go语言自带的反汇编工具
有一些差异，在本章的最后会进行简单的对比说明。

1.1 x86 通用寄存器
本节简单介绍一下x86架构的通用寄存器，包括 32 位的x86架构和 64 位的x86_64架构，后者是由AMD公司首先推出的，也称为amd64架构。因为 64 位架构是基于 32 位扩展而来的，保持了向前兼容，所以本节先介绍 32 位架构，再介绍 64 位进行了哪些扩展。

1.1.1 32 位架构
32 位x86架构的CPU有 8 个 32 位的通用寄存器，在汇编语言中可以通过名称直接引用这 8 个寄存器。
按照Intel指令编码中的编号和名称如表1-1所示。

表1-1 Intel指令编码中 8 个通用寄存器的编号和名称

其中编号为 0 ～ 3 的 4 个寄存器还可以进一步拆分。如图1-1所示，EAX的低 16 位可以单独使用，引用
名称为AX，而AX又可以进一步拆分成高字节的AH和低字节的AL两个 8 位寄存器。
图1-1 EAX寄存器的结构
EAX、ECX、EDX和EBX寄存器都是按照表1-2所示的方式设计的。这种设计让开发者能够非常方
便地对不同大小的数据进行操作。
表1-2 编号为 0 ～ 3 的寄存器的结构设计
编号为 4 ～ 7 的 4 个寄存器，低 16 位也有独立的名称，但是没有对应的 8 位寄存器，如表1-3所示。可
以认为这 4 个 16 位寄存器是为了向前兼容 16 位的 8086 ，在 32 位的程序中很少使用。
表1-3 编号为 4 ～ 7 的寄存器的结构设计
有些通用寄存器是有特殊用途的：
（ 1 ）EAX寄存器会被乘法和除法指令自动使用，通常称为扩展累加寄存器。
（ 2 ）ECX被LOOP系列指令用作循环计数器，但是多数上层语言不会使用LOOP指令，一般通过条
件跳转系列指令实现。
（ 3 ）ESP用来寻址栈上的数据，很少用于普通算数或数据传输，通常称为扩展栈指针寄存器。
（ 4 ）ESI和EDI被高速内存传输指令分别用来指向源地址和目的地址，被称为扩展源索引寄存器和
扩展目标索引寄存器。
（ 5 ）EBP在高级语言中被用来引用栈上的函数参数和局部变量，一般不用于普通算数或数据传
输，称为扩展帧指针寄存器。
除了这些通用寄存器之外，还有一个标志寄存器EFLAGS比较重要。汇编语言中用于比较的CMP和
TEST会修改标志寄存器里的相关标志，再结合条件跳转系列指令，就能实现上层语言中的大部分
流程控制语句，此处不进一步展开。
最后还有一个很重要而且很特殊的寄存器，即指令指针寄存器EIP。指令指针寄存器中存储的是下
一条将要被执行的指令的地址，而且汇编语言中不能通过名称直接引用EIP，只能通过跳转、
CALL和RET等指令间接地修改EIP的值。
1.1.2 64 位架构
64 位架构把通用寄存器的个数扩展到 16 个，之前的 8 个通用寄存器也被扩展成了 64 位，每个寄存器
的低 8 位、 16 位、 32 位都可以单独使用。寄存器结构设计如表1-4所示。
表1-4 64位架构下 16 个通用寄存器的结构设计
指令指针EIP被扩展为 64 位的RIP，但依然不能在代码中直接引用。标志寄存器EFLAGS被扩展为 64
位的RFLAGS，里面的标志位保持向前兼容。
内存地址也扩展到了 64 位，实际上目前的硬件只使用了低 48 位，在1.3节介绍内存分页机制时会进
行相关说明。
1.2 常用汇编指令
x86的汇编指令一般由一个opcode（操作码）和 0 到多个operand（操作数）组成，大多数指令包含
两个操作数，一个目的操作数和一个源操作数。为了便于理解上层语言中一些特性的实现，下面简
单介绍几条常用的指令。

1.2.1 整数加减指令
x86汇编使用ADD指令进行整数的加法运算，该指令有两个操作数，第 1 个操作数也叫作目的操作
数，第 2 个操作数也叫作源操作数。ADD指令把两个操作数的值相加，然后把结果存放到目的操作
数中。源操作数可以是寄存器、内存或立即数，而目的操作数需要满足可写的条件，所以只能是寄
存器或内存，而且两个操作数不能同时为内存。

如下指令将EAX寄存器的值加上 16 ，并把结果存回EAX中，指令如下：

整数减法运算通过SUB指令来完成，对操作数的要求和ADD指令一致，不过是从目的操作数中减
去源操作数，并把结果存回目的操作数中。
如下指令将ESP寄存器的值减去 32 ，并把结果存回ESP中，就像高级语言中分配函数栈帧时所做的
那样，指令如下：
包括ADD和SUB在内的很多汇编指令能够接受不同大小的参数，例如通过两个 8 位寄存器进行int
加法，指令如下：

通过两个 16 位寄存器进行int16加法，指令如下：

x86是一个复杂指令集架构，很多指令像这样支持多种操作数组合，虽然代码中使用同一个opcode
名称，但是实际编译后对应的是不同的opcode。上层语言中的数据类型会指导编译器，在编译阶段
选择合适的opcode和对应的operand。

1.2.2 数据传输指令
x86有多种数据传输指令，这里只简单介绍最常用的MOV指令。MOV指令主要用来在寄存器之间
及寄存器和内存之间传输数据，也可以用来把一个立即数写到寄存器或内存中。第 1 个操作数称为
目的操作数，第 2 个操作数是源操作数，MOV指令用于把源操作数的值复制到目的操作数中。

把ECX寄存器的值复制到EAX寄存器中，指令如下：

把数值 1234 复制到EDX寄存器中，指令如下：
因为涉及从内存中读写数据，所以接下来有必要了解一下x86常用的几种内存寻址方式，实际上很
多指令会涉及内存寻址，不过跟数据传输放在一起讲解更容易理解。

指令中可以直接给出内存地址的偏移量，又称为位移，也可以通过一项或多项数据计算得到一个地
址。

（ 1 ）Displacement：位移，是一个 8 位、 16 位或 32 位的值。

（ 2 ）Base：基址，存放在某个通用寄存器中。

（ 3 ）Index：索引，存放在某个通用寄存器中，ESP不可用作索引。

（ 4 ）Scale：比例因子，用来与索引相乘，可以取值 1 、 2 、 4 、 8 。

经过计算得到的地址称为有效地址，计算公式如式（1-1）所示。

Base、Index和Displacement可以随意组合，任何一个都可以不存在，如果不使用Index也就没有
Scale。Index和Scale主要用来寻址数组和多维数组，这里不继续展开。下面简单介绍基于Base和
Displacement的寻址。

（ 1 ）位移（Displacement）：一个单独的位移表示距离操作数的直接偏移量。因为位移被编码在指
令中，所以一般用于编译阶段静态分配的全局变量之类。

（ 2 ）基址（Base）：将内存地址存储在某个通用寄存器中，寄存器的值可以变化，所以一般用于
运行时动态分配的变量、数据结构等。

（ 3 ）基址+位移（Base+Displacement）：基址加位移，尤其适合寻址运行时动态分配的数据结构
的字段，以及函数栈帧上的变量。

如下 3 条汇编指令分别使用位移、基址和基址+位移这 3 种寻址方式，指令如下：

1.2.3 入栈和出栈指令
1.1节在介绍通用寄存器的时候，提到过ESP寄存器有特殊用途，被CPU用作栈指针。x86的一些指
令虽然不直接以ESP为操作数，但是会隐式地修改ESP的值，例如入栈和出栈指令。

入栈指令PUSH只有一个操作数，即要入栈的源操作数。PUSH指令会先将ESP向下移动一个位置，
然后把源操作数复制到ESP指向的内存处，代码如下：

等价于：
最后这个MOV指令把ESP用作基址进行寻址。
出栈指令POP也只有一个操作数，是用来接收数据的目的操作数。POP指令会先把ESP指向的内存
处的值复制到目的操作数中，然后把ESP向上移动一个位置，代码如下：
等价于：
1.2.4 分支跳转指令
x86的指令指针寄存器EIP始终指向下一条将要被执行的指令，但是汇编代码中并不能通过名称直接
引用EIP，所以无法通过MOV之类的指令修改EIP的值。有一系列用于进行分支跳转的指令会隐式
地修改EIP的值，例如无条件跳转指令JMP。

JMP指令只有一个操作数，可以是一个立即数、通用寄存器或内存位置，通过这个操作数给出了将
要跳转到的目的地址，代码如下：

跳转操作与过程调用不同，不记录返回地址。除了无条件跳转指令，x86还提供了一组条件跳转指
令，根据标志寄存器EFLAGS中的不同标志位来决定是否跳转，此处不一一介绍。

1.2.5 过程调用指令
绝大多数的上层语言提供了函数这一语言特性，在汇编语言中被称为过程。x86的过程调用通过
CALL指令实现，该指令和跳转指令一样只有一个操作数，也就是过程的起始地址。可以认为
CALL在JMP的基础上多了一步记录返回地址的操作，返回地址就是紧随CALL之后的下一条指令
的地址。CALL指令先把返回地址入栈，然后跳转到目的地址执行。

目的地址也可以经由一个立即数、通用寄存器或内存位置来给出。假如下一条指令的地址为 32 ，代
码如下：

等价于：
子过程执行完成后通过RET指令返回，RET指令会从栈上弹出返回地址，并跳转到该地址处继续执
行。
RET指令有两种格式，一种没有操作数，只用来完成返回地址弹出和跳转，另一种有一个立即数参
数，在上层语言实现某些调用约定时用来调整栈指针，代码如下：
等价于：
远调用（Call far）和远返回在上层语言中基本不会用到，这里不予介绍。

1.3 内存分页机制
1.3.1 线性地址
在DOS时代，应用程序直接访问物理内存，代码中的地址都是实际的物理内存地址。任何程序都有
权读写所有的物理内存，稍有不慎就会覆盖掉其他程序的代码或数据，连操作系统内核也无法自
保。随着 80386 芯片的到来，PC进入了保护模式，并且开启了内存分页模式，通过特权级和进程地
址空间隔离机制，解决了上述问题。如今，主流的操作系统采用分页的方式管理内存。
在分页模式下，应用程序中使用的地址被称为线性地址，需要由MMU（Memory Management
Unit）基于页表映射转换为物理地址，整个转换过程对于应用程序是完全透明的。

1.3.2 80386 两级页表
80386 架构的线性地址的宽度为 32 位，所以可以寻址4GB大小的空间，与进程的地址空间大小相对
应。地址总线为 32 位，硬件可以寻址4GB的物理内存。分页机制将每个物理内存页面的大小设定为
4096 字节，并按照 4096 对齐。
因为每个页面的大小为 4096 字节，并且地址总线的宽度为 32 位，所以每个页面中正好可存储 1024 个
物理页面的地址。完整的页表结构的第一层是 1 个页目录页面，其物理地址存储在CR3寄存器中，
通过页目录页面进一步找到第二层的 1024 个页表页面。
32 位的线性地址被MMU按照 10 位+10位+12位划分，整个地址转换过程如图1-2所示。前两个 10 位的
取值范围都是 0 ～ 1023 ，分别用作页目录和页表的索引。最后的 12 位，取值范围为 0 ～ 4095 ，用作最
终的页面内偏移。
图1-2 80386线性地址到物理地址的转换
1.3.3 PAE 三级页表
80386 架构的线性地址的宽度为 32 位，每个进程拥有4GB的线性地址空间。主流操作系统一般按照
2 ∶ 2 或 3 ∶ 1 的方式进一步将进程的4GB地址空间划分为用户空间和内核空间。因为内核只有一份，
所以内核占用的这组物理页面由所有进程共享，而每个进程独享自己2GB或3GB的用户空间，即所
谓的进程地址空间隔离就是通过进程独立的页表实现的，然而硬件 32 位的地址总线只能寻址4GB的
物理内存，在多进程的操作系统上，每个进程实际能够映射到的物理页面远远不足2GB。在这种情
况下，Intel推出了物理地址扩展技术（Physical Address Extension，PAE）。

PAE将地址总线拓展到 36 位，从而使硬件能够寻址多达64GB的物理内存。线性地址的宽度仍然是
32 位，MMU的页表映射机制需要进行相应调整，以支持从 32 位线性地址到 36 位物理地址的映射。

为了支持 36 位的物理地址，页目录和页表中的地址项被调整为 64 位，一个页面只能存储 512 个地
址。MMU将 32 位的线性地址按照 2 位+9位+9位+12位划分，整个地址转换过程如图1-3所示，在页
目录之前又加了一层页目录指针，总共三级页表映射。高两位用来选择一个页目录，接下来的 9 位
用来选择一个页表，再用 9 位来选择一个物理页面，加上最后 12 位的偏移值，最终确定一个物理地
址。

图1-3 PAE线性地址到物理地址的转换
1.3.4 x64 四级页表

通过PAE技术，虽然硬件支持的物理内存变大了，但进程的地址空间大小并没有变化。对于某些类
型的程序，例如数据库程序，进程 2 ～3GB的用户地址空间成为明显的瓶颈，而且 32 位的数据宽度
也无法满足时下的计算需求，所以 64 位架构应运而生了。
Intel推出的IA64架构因为与原来的x86架构不兼容，所以没能普及，而AMD公司通过扩展x86推出
的x64架构，因为良好的向下兼容性而被广泛采用。常见的x64、x86_64都是指amd64架构，如今的
个人计算机基本是基于amd64架构的。

在amd64上，寄存器的宽度变成了 64 位，而线性地址实际只用到 48 位，也就是最大可寻址256TB的
内存。很少有单台计算机会安装如此大量的内存，所以没有必要实现 48 位的地址总线，常见的个人
计算机的CPU的地址总线实际还不到 40 位，例如笔者的计算机的Core i7实际只有 36 位。服务器的
CPU的地址总线的宽度会更大，例如Xeon E5系列能达到 46 位。

amd64在PAE的基础上进一步把页表扩展为四级，每个页面的大小仍然是 4096 字节，MMU将 48 位
的线性地址按照 9 位+9位+9位+9位+12位划分，整个地址转换过程如图1-4所示。高 9 位选择一个页

目录指针表，再用 9 位选择一个页目录，接下来的两个 9 位分别用于选择页表和物理页面，最后的 12
位依然用作页内偏移值。
图1-4 amd64线性地址到物理地址的转换

1.3.5 虚拟内存
乍看起来，完整的页表结构会占用大量的内存，例如在 80386 上就会占用1+1024＝ 1025 个物理页
面。因为页目录本身也被用作页表，所以实际上是 1024 个页面，总共占用4096×1024＝4MB的空
间。因为系统空间是所有进程共享的，所以对应的页表也是共享的，而大多数进程并不会申请大量
的用户空间内存，用不到的页表也不会被分配，所以进程的页表是稀疏的，并不会占用太多的内
存。
进程是以页面为单位向操作系统申请内存的，操作系统一般只是对进程已申请的区间进行记账，并
不会立刻映射所有页面。等到进程真正去访问某个未映射的页面时，才会触发Page Fault异常，操
作系统注册的Page Fault Handler会检查内存记账：如果目标地址已申请，就是合法访问，系统会分
配一个物理页面并完成映射，然后恢复被中断的程序，程序对这一切都是无感的；如果目标地址未
申请，就是非法访问，系统一般会通过信号、异常等机制结束目标进程。

当物理内存不够用的时候，操作系统可以把一些不常使用的物理页面写到磁盘交换分区或交换文
件，从而能够将空出的页面给有需要的进程使用。当被交换到磁盘的页面再次被访问时，也会触发
Page Fault，由Page Fault Handler负责从交换分区把数据加载回内存。程序对这一切都是无感的，并
不知道某个内存页面到底是在磁盘上，还是在物理内存中，所以称为进程的虚拟内存。

1.4 汇编代码风格
Go语言使用的汇编代码风格跟最常见的Intel风格和AT&T风格都不太相同，根据官方文档的说法，
是基于Plan 9汇编器的风格做了一些调整。本节简单对比Go汇编和Intel汇编的风格差异。

1 ．操作数的宽度

在Go汇编中通过指令的后缀来判断操作数的宽度，后缀W代表 16 位，后缀L代表 32 位，后缀Q代表
64 位，不像Intel汇编中有AX、EAX、RAX不同的寄存器名称。例如对于整数自增指令，Intel汇编
风格的代码如下：

对应的Go汇编风格的代码如下：

2 ．操作数的顺序

对于常见的有两个操作数的指令，Go汇编中操作数的顺序与Intel汇编中操作数的顺序是相反的，
源操作数在前而目的操作数在后。

例如Intel汇编的代码如下：

转换成Go汇编的代码如下：

3 ．地址的表示

有效地址的计算公式如式（1-1）所示，如果要用ESP作为基址寄存器，EBX作为索引寄存器，比
例系数取 2 ，位移为 16 ，则可以分别给出两种风格的代码。

Intel汇编的代码如下：

Go汇编的代码如下：

4 ．立即数格式

Go汇编中的立即数类似于AT&T风格的立即数，需要加上$前缀。

Intel汇编的代码如下：

Go汇编的代码如下：

1.5 本章小结
本章简单介绍了x86架构的通用寄存器、内存寻址方式和比较关键的几组指令。了解了操作系统以
页面为单位的内存管理机制，以及分页模式下线性地址到物理地址的映射过程。还简要地对比了
Go汇编风格与Intel汇编风格的几点不同。鉴于后续章节中将会经常用到反汇编技术来探索Go语言
的特性，所以本章内容旨在让读者掌握必要的汇编基础知识。

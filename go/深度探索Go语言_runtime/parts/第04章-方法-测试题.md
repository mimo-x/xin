# 第4章 方法 - 读后测试题

## 第一部分:问题

### 一、概念理解题

1. **接收者类型**
   - Go语言方法的接收者与函数参数有什么关系?
   - 值接收者和指针接收者在传递方式上有什么区别?

2. **方法调用机制**
   - 通过对象调用方法(p.X())与通过完全限定名调用(Point.X(p))有什么区别?
   - 为什么值接收者方法可以通过指针调用,反之亦然?

3. **包装方法**
   - 编译器为什么要为值接收者方法生成指针接收者的包装方法?
   - 包装方法的内部逻辑包含哪些检查和处理?

4. **Method Value**
   - 基于类型的Method Value和基于对象的Method Value有什么区别?
   - Method Value的底层实现与Function Value有什么联系?

5. **组合式继承**
   - Go语言的组合式继承与传统OOP的继承有什么不同?
   - 嵌入值和嵌入指针在内存布局和方法继承上有什么区别?

### 二、代码分析题

1. **接收者传递**
   ```go
   type Point struct {
       x, y float64
   }

   func (p Point) X() float64 {
       return p.x
   }

   func (p *Point) SetX(x float64) {
       p.x = x
   }
   ```
   绘制调用p.X()和p.SetX(10)时的栈帧布局,标注接收者的位置。

2. **包装方法调用**
   ```go
   type Point struct {
       x float64
   }

   func (p Point) Get() float64 {
       return p.x
   }

   func main() {
       p := &Point{x: 10}
       v := p.Get()  // 实际调用的是哪个方法?
   }
   ```
   分析这段代码的执行流程,说明包装方法的作用。

3. **Method Value分析**
   ```go
   type Counter struct {
       count int
   }

   func (c *Counter) Inc() {
       c.count++
   }

   func main() {
       c := &Counter{count: 0}

       f1 := c.Inc              // 基于对象
       f2 := (*Counter).Inc     // 基于类型

       f1()
       f2(c)
   }
   ```
   - f1和f2的类型分别是什么?
   - f1的底层结构是怎样的?
   - f1和f2在性能上有差异吗?

4. **组合继承**
   ```go
   type Base struct {
       value int
   }

   func (b Base) Get() int {
       return b.value
   }

   func (b *Base) Set(v int) {
       b.value = v
   }

   type Derived struct {
       Base
       extra string
   }

   func main() {
       d := Derived{Base{10}, "test"}

       v1 := d.Get()       // 调用哪个方法?
       d.Set(20)           // 是否能修改d.Base.value?

       d2 := &Derived{Base{10}, "test"}
       d2.Get()            // 调用哪个方法?
       d2.Set(20)          // 是否能修改?
   }
   ```
   分析每个方法调用实际执行的是哪个包装方法或原始方法。

5. **多重继承冲突**
   ```go
   type A struct {
       value int
   }

   func (a A) Get() int {
       return a.value
   }

   type B struct {
       value int
   }

   func (b B) Get() int {
       return b.value * 2
   }

   type C struct {
       A
       B
   }

   func main() {
       c := C{A{10}, B{20}}
       // v := c.Get()  // 编译错误还是能运行?
   }
   ```
   这段代码有什么问题?如何解决?

### 三、实践编程题

1. **方法集分析**
   编写程序,使用反射分析以下类型的方法集:
   ```go
   type T struct{}

   func (t T) ValueMethod() {}
   func (t *T) PointerMethod() {}
   ```
   分别打印T和*T的所有方法。

2. **性能对比**
   实现以下三种调用方式并进行性能测试:
   ```go
   // 方式1: 直接调用
   p.Method()

   // 方式2: 基于类型的Method Value
   f := (*Point).Method
   f(&p)

   // 方式3: 基于对象的Method Value
   f := p.Method
   f()
   ```
   比较三种方式的性能差异。

3. **包装方法生成**
   编写一个函数,使用反射为值接收者方法动态生成指针接收者的包装方法。

4. **继承链分析**
   ```go
   type A struct {
       a int
   }

   type B struct {
       A
       b int
   }

   type C struct {
       B
       c int
   }
   ```
   编写程序遍历C的所有嵌入字段,并打印继承的方法列表。

5. **方法覆盖**
   实现一个支持方法覆盖的组合模式:
   ```go
   type Base struct{}

   func (b Base) Process() string {
       return "base"
   }

   type Derived struct {
       Base
   }

   func (d Derived) Process() string {
       return "derived: " + d.Base.Process()
   }
   ```
   验证Derived.Process()能否正确覆盖Base.Process()。

### 四、综合应用题

1. **接口实现**
   ```go
   type Reader interface {
       Read() string
   }

   type File struct {
       content string
   }

   func (f File) Read() string {
       return f.content
   }

   func main() {
       var r Reader = File{"hello"}  // 能否编译通过?
       var r Reader = &File{"hello"} // 能否编译通过?
   }
   ```
   结合方法集和包装方法,解释为什么值类型和指针类型在实现接口时的行为。

2. **方法表**
   Go编译器如何为类型生成方法表?
   - 值类型的方法表包含哪些方法?
   - 指针类型的方法表包含哪些方法?
   - 方法表与接口的itab有什么关系?

3. **嵌入字段的方法提升**
   ```go
   type Inner struct {
       value int
   }

   func (i Inner) String() string {
       return fmt.Sprintf("%d", i.value)
   }

   type Outer struct {
       Inner
       name string
   }

   func main() {
       o := Outer{Inner{10}, "test"}
       fmt.Println(o)  // 调用哪个String方法?
   }
   ```
   分析fmt.Println如何查找和调用String方法。

4. **方法值的逃逸**
   ```go
   type Counter struct {
       count int
   }

   func (c *Counter) Inc() {
       c.count++
   }

   func getInc(c *Counter) func() {
       return c.Inc
   }
   ```
   分析Counter对象和Method Value在内存中的分配位置。

5. **组合vs接口**
   对比组合式继承和接口实现的优缺点:
   - 代码复用
   - 类型安全
   - 性能开销
   - 灵活性

   在什么场景下应该选择组合?什么场景下选择接口?

---

## 第二部分:答案与解析

### 一、概念理解题答案

1. **接收者类型**

   **答案:**

   - **接收者与参数的关系:**
     - 接收者本质上是隐式的第一个参数
     - 通过栈传递,与普通参数一样
     - 不使用特殊寄存器(如C++的this)

   - **值接收者 vs 指针接收者:**

   | 特性 | 值接收者 | 指针接收者 |
   |------|----------|------------|
   | 传递内容 | 完整对象的拷贝 | 对象地址(8字节) |
   | 能否修改原对象 | 否 | 是 |
   | 栈帧大小 | 依赖对象大小 | 固定8字节 |
   | 性能 | 大对象慢 | 总是快 |

   **示例:**
   ```go
   type Large struct {
       data [1000]int
   }

   func (l Large) Value() {}    // 拷贝8000字节
   func (l *Large) Pointer() {} // 拷贝8字节

   // 栈帧布局对比:
   // Value():  8000字节接收者 + 其他
   // Pointer(): 8字节接收者 + 其他
   ```

2. **方法调用机制**

   **答案:**

   - **对象调用 vs 完全限定名调用:**

   ```go
   type Point struct { x float64 }
   func (p Point) X() float64 { return p.x }

   p := Point{10}

   // 方式1: 对象调用
   v1 := p.X()

   // 方式2: 完全限定名调用
   v2 := Point.X(p)
   ```

   **区别:**
   - 本质相同: p.X()是语法糖,编译器转换为Point.X(p)
   - 汇编代码一致
   - 方式2显式传递接收者

   - **跨类型调用的自动转换:**

   ```go
   type T struct{}
   func (t T) Value() {}
   func (t *T) Pointer() {}

   t := T{}
   p := &T{}

   // 值→指针: 自动取地址
   t.Pointer()  // 编译器: (&t).Pointer()

   // 指针→值: 自动解引用
   p.Value()    // 编译器: (*p).Value()
   ```

   **规则:**
   - 值可以调用指针方法: 编译器自动取地址
   - 指针可以调用值方法: 通过包装方法或解引用
   - 前提: 对象是可寻址的(变量,非临时值)

3. **包装方法**

   **答案:**

   编译器为值接收者方法生成指针接收者包装方法的原因:

   **主要目的: 接口实现**

   ```go
   type T struct{}
   func (t T) Method() {}

   // 编译器生成:
   func (t *T) Method() {  // 包装方法
       if t == nil {
           panic(...)
       }
       (*t).Method()  // 调用原方法
   }
   ```

   **包装方法的检查:**

   ```asm
   ; 伪代码
   TEXT (*Point).X(SB)
       ; 1. 栈增长检查
       CMP stackguard0, SP
       JBE morestack

       ; 2. panic参数调整
       if in_panic {
           adjust_panic_argp()
       }

       ; 3. nil检查
       MOV receiver, AX
       TEST AX, AX
       JZ panic_nil_pointer

       ; 4. 解引用并调用原方法
       CALL Point.X(*receiver)
   ```

   **为什么需要包装:**
   ```go
   type Reader interface {
       Read() string
   }

   type File struct {
       content string
   }

   func (f File) Read() string {
       return f.content
   }

   // 两种实现都要支持:
   var r Reader = File{"hello"}   // File实现接口
   var r Reader = &File{"hello"}  // *File也要实现接口

   // 没有包装方法,*File无法实现Reader接口
   ```

4. **Method Value**

   **答案:**

   **基于类型 vs 基于对象:**

   ```go
   type Point struct { x float64 }
   func (p Point) Get() float64 { return p.x }

   p := Point{10}

   // 基于类型
   f1 := Point.Get
   // 类型: func(Point) float64
   // 底层: 函数指针(二级指针)
   // 调用: f1(p)

   // 基于对象
   f2 := p.Get
   // 类型: func() float64
   // 底层: 闭包对象
   // 调用: f2()
   ```

   **底层实现对比:**

   ```
   基于类型 (Method Expression):
   ┌──────────┐
   │ funcval  │
   ├──────────┤
   │ fn指针   │ → Point.Get函数
   └──────────┘

   基于对象 (Method Value):
   ┌──────────┐
   │ funcval  │
   ├──────────┤
   │ fn指针   │ → 包装函数
   ├──────────┤
   │ p.x = 10 │  捕获的Point对象
   └──────────┘
   ```

   **与Function Value的关系:**
   - Method Value本质是Function Value
   - 基于类型: 简单的函数指针
   - 基于对象: 闭包(捕获接收者)

5. **组合式继承**

   **答案:**

   **Go组合 vs 传统继承:**

   | 特性 | Go组合 | 传统继承(C++/Java) |
   |------|--------|---------------------|
   | 语法 | 嵌入字段 | extends/: |
   | 关系 | has-a | is-a |
   | 虚函数 | 无 | 有 |
   | 方法覆盖 | 名字遮蔽 | 动态绑定 |
   | 多重继承 | 支持 | C++支持,Java不支持 |
   | 访问基类 | 显式字段名 | base/super |

   **嵌入值 vs 嵌入指针:**

   ```go
   // 嵌入值
   type Point struct { x float64 }
   type Point3D struct {
       Point  // 值嵌入
       z float64
   }

   // 内存布局: 连续
   // Point3D: [x][z]
   // Point3D大小: 16字节

   // 嵌入指针
   type Point3D struct {
       *Point  // 指针嵌入
       z float64
   }

   // 内存布局: 分离
   // Point3D: [*Point][z]
   // Point3D大小: 16字节
   // Point: [x] (独立分配)
   ```

   **方法继承差异:**

   | 特性 | 嵌入值 | 嵌入指针 |
   |------|--------|----------|
   | 值方法 | 继承 | 继承 |
   | 指针方法 | 不继承(T) | 继承 |
   | 值方法 | 继承(*T) | 继承(*T) |
   | 指针方法 | 继承(*T) | 继承(*T) |

### 二、代码分析题答案

1. **接收者传递**

   **答案:**

   ```go
   type Point struct {
       x, y float64
   }

   func (p Point) X() float64 {
       return p.x
   }

   func (p *Point) SetX(x float64) {
       p.x = x
   }
   ```

   **调用 p.X() 的栈帧:**
   ```
   高地址
   ┌────────────────┐
   │  caller frame  │
   ├────────────────┤
   │  返回值(8字节)  │  +24(SP)
   ├────────────────┤
   │  p.y (8字节)   │  +16(SP) ← 接收者(Point结构体)
   ├────────────────┤
   │  p.x (8字节)   │  +8(SP)
   ├────────────────┤
   │  返回地址       │  0(SP)
   ├────────────────┤ ← X()的SP
   │  局部变量       │
   └────────────────┘
   低地址

   传递内容: 完整的Point结构体(16字节)
   ```

   **调用 p.SetX(10) 的栈帧:**
   ```
   高地址
   ┌────────────────┐
   │  caller frame  │
   ├────────────────┤
   │  参数x=10      │  +16(SP)
   ├────────────────┤
   │  &p (8字节)    │  +8(SP) ← 接收者(指针)
   ├────────────────┤
   │  返回地址       │  0(SP)
   ├────────────────┤ ← SetX()的SP
   │  局部变量       │
   └────────────────┘
   低地址

   传递内容: Point对象的地址(8字节)
   ```

2. **包装方法调用**

   **答案:**

   ```go
   type Point struct {
       x float64
   }

   func (p Point) Get() float64 {
       return p.x
   }

   func main() {
       p := &Point{x: 10}
       v := p.Get()  // 调用包装方法
   }
   ```

   **执行流程:**

   1. **编译阶段生成包装方法:**
      ```go
      // 编译器自动生成
      func (p *Point) Get() float64 {
          // 1. 检查p != nil
          if p == nil {
              panic("nil pointer")
          }

          // 2. 解引用并调用原方法
          return (*p).Get()
      }
      ```

   2. **调用链:**
      ```
      main中: p.Get()
         ↓
      包装方法: (*Point).Get(p)
         ↓ nil检查
         ↓ 解引用 *p
         ↓
      原方法: Point.Get(*p)
      ```

   3. **汇编级别:**
      ```asm
      ; 包装方法
      TEXT (*Point).Get(SB)
          ; 检查nil
          MOV 8(SP), AX        ; AX = p
          TESTQ AX, AX
          JZ panic_nil

          ; 解引用
          MOVSD 0(AX), X0      ; X0 = p.x

          ; 准备调用原方法
          MOVSD X0, 8(SP)      ; 栈上放置Point值

          ; 调用
          CALL Point.Get(SB)
          RET
      ```

   **包装方法的作用:**
   - 支持指针类型调用值接收者方法
   - 提供nil检查保护
   - 支持接口实现

3. **Method Value分析**

   **答案:**

   ```go
   type Counter struct {
       count int
   }

   func (c *Counter) Inc() {
       c.count++
   }

   func main() {
       c := &Counter{count: 0}

       f1 := c.Inc              // 基于对象
       f2 := (*Counter).Inc     // 基于类型

       f1()
       f2(c)
   }
   ```

   **类型分析:**

   ```go
   // f1的类型
   var f1 func()           // 无参数

   // f2的类型
   var f2 func(*Counter)   // 需要传递接收者
   ```

   **f1的底层结构(闭包):**

   ```
   堆上分配:
   ┌─────────────────┐
   │  funcval对象    │  f1指向这里
   ├─────────────────┤
   │  fn指针         │ → Counter.Inc-fm包装函数
   ├─────────────────┤
   │  c指针          │ → 捕获的Counter对象
   └─────────────────┘

   包装函数Counter.Inc-fm:
   func (包装函数) {
       c := 从闭包获取
       (*Counter).Inc(c)
   }
   ```

   **f2的底层结构:**

   ```
   编译时静态分配:
   ┌─────────────────┐
   │  函数指针       │ → (*Counter).Inc
   └─────────────────┘
   ```

   **性能对比:**

   ```go
   func BenchmarkMethodValue(b *testing.B) {
       c := &Counter{}
       f := c.Inc
       b.ResetTimer()
       for i := 0; i < b.N; i++ {
           f()  // 闭包调用,有间接开销
       }
   }

   func BenchmarkMethodExpression(b *testing.B) {
       c := &Counter{}
       f := (*Counter).Inc
       b.ResetTimer()
       for i := 0; i < b.N; i++ {
           f(c)  // 直接调用,无额外开销
       }
   }

   // 结果:
   // BenchmarkMethodValue-8      500000000   3.5 ns/op
   // BenchmarkMethodExpression-8 1000000000  2.8 ns/op
   ```

   **差异原因:**
   - f1需要额外的闭包查找
   - f2是直接函数调用
   - 差异不大(~20%),可忽略

4. **组合继承**

   **答案:**

   ```go
   type Base struct {
       value int
   }

   func (b Base) Get() int {
       return b.value
   }

   func (b *Base) Set(v int) {
       b.value = v
   }

   type Derived struct {
       Base
       extra string
   }
   ```

   **场景1: d := Derived{Base{10}, "test"}**

   ```go
   v1 := d.Get()  // 调用哪个方法?
   ```

   **答案: 调用Derived.Get包装方法**

   ```go
   // 编译器生成
   func (d Derived) Get() int {
       return d.Base.Get()  // 转发给Base.Get
   }
   ```

   ```go
   d.Set(20)  // 能否修改d.Base.value?
   ```

   **答案: 不能修改**

   **原因:**
   - d是值类型
   - d.Set()等价于 Derived.Set(d)
   - 编译器生成:
     ```go
     func (d Derived) Set(v int) {
         (&d.Base).Set(v)  // 修改的是d的副本
     }
     ```
   - d本身未被修改

   **场景2: d2 := &Derived{Base{10}, "test"}**

   ```go
   d2.Get()   // 调用哪个方法?
   ```

   **答案: 调用(*Derived).Get包装方法**

   ```go
   // 编译器生成
   func (d *Derived) Get() int {
       return d.Base.Get()  // 转发
   }
   ```

   ```go
   d2.Set(20)  // 能否修改?
   ```

   **答案: 能修改**

   **原因:**
   - d2是指针类型
   - d2.Set(20)等价于 (*Derived).Set(d2, 20)
   - 编译器生成:
     ```go
     func (d *Derived) Set(v int) {
         (&d.Base).Set(v)  // 通过指针修改
     }
     ```
   - d2.Base.value被成功修改

   **总结:**

   | 接收者类型 | 嵌入值Get | 嵌入指针Set | 效果 |
   |-----------|----------|-------------|------|
   | Derived   | ✓继承    | ✗不能修改   | 值拷贝 |
   | *Derived  | ✓继承    | ✓能修改     | 指针 |

5. **多重继承冲突**

   **答案:**

   ```go
   type A struct {
       value int
   }

   func (a A) Get() int {
       return a.value
   }

   type B struct {
       value int
   }

   func (b B) Get() int {
       return b.value * 2
   }

   type C struct {
       A
       B
   }

   func main() {
       c := C{A{10}, B{20}}
       v := c.Get()  // 编译错误!
   }
   ```

   **编译错误:**
   ```
   ambiguous selector c.Get
   ```

   **原因:**
   - A和B都有Get方法
   - 嵌入层次相同(都是第一层)
   - 编译器无法决定调用哪个

   **解决方案:**

   ```go
   // 方案1: 显式指定
   v1 := c.A.Get()  // 调用A.Get
   v2 := c.B.Get()  // 调用B.Get

   // 方案2: 为C实现Get方法(覆盖)
   func (c C) Get() int {
       return c.A.Get() + c.B.Get()
   }

   // 方案3: 调整嵌入层次
   type Inner struct {
       A
   }

   type C struct {
       Inner  // A在第二层
       B      // B在第一层
   }

   c := C{Inner{A{10}}, B{20}}
   v := c.Get()  // 调用B.Get (B层次更浅)

   // 方案4: 使用接口
   type Getter interface {
       Get() int
   }

   func process(g Getter) int {
       return g.Get()
   }

   process(c.A)  // 明确传递A
   process(c.B)  // 明确传递B
   ```

### 三、实践编程题答案

1. **方法集分析**

   **答案:**

   ```go
   package main

   import (
       "fmt"
       "reflect"
   )

   type T struct{}

   func (t T) ValueMethod() {}
   func (t *T) PointerMethod() {}

   func printMethodSet(typ reflect.Type) {
       fmt.Printf("\nType: %v\n", typ)
       fmt.Printf("方法数量: %d\n", typ.NumMethod())

       for i := 0; i < typ.NumMethod(); i++ {
           method := typ.Method(i)
           fmt.Printf("  %d. %s: %v\n", i+1, method.Name, method.Type)
       }
   }

   func main() {
       t := T{}

       // 分析T的方法集
       tType := reflect.TypeOf(t)
       printMethodSet(tType)

       // 分析*T的方法集
       pType := reflect.TypeOf(&t)
       printMethodSet(pType)
   }
   ```

   **输出:**
   ```
   Type: main.T
   方法数量: 1
     1. ValueMethod: func(main.T)

   Type: *main.T
   方法数量: 2
     1. PointerMethod: func(*main.T)
     2. ValueMethod: func(*main.T)  ← 包装方法
   ```

   **方法集规则:**
   ```
   类型T的方法集:
   - T的所有值接收者方法

   类型*T的方法集:
   - T的所有值接收者方法(通过包装)
   - *T的所有指针接收者方法
   ```

2. **性能对比**

   **答案:**

   ```go
   package main

   import "testing"

   type Point struct {
       x, y float64
   }

   func (p *Point) Distance() float64 {
       return p.x + p.y
   }

   // 方式1: 直接调用
   func BenchmarkDirect(b *testing.B) {
       p := &Point{3, 4}
       b.ResetTimer()
       for i := 0; i < b.N; i++ {
           _ = p.Distance()
       }
   }

   // 方式2: 基于类型的Method Value
   func BenchmarkMethodExpression(b *testing.B) {
       p := &Point{3, 4}
       f := (*Point).Distance
       b.ResetTimer()
       for i := 0; i < b.N; i++ {
           _ = f(p)
       }
   }

   // 方式3: 基于对象的Method Value
   func BenchmarkMethodValue(b *testing.B) {
       p := &Point{3, 4}
       f := p.Distance
       b.ResetTimer()
       for i := 0; i < b.N; i++ {
           _ = f()
       }
   }
   ```

   **测试结果:**
   ```bash
   go test -bench=. -benchmem

   BenchmarkDirect-8            1000000000   0.5 ns/op   0 B/op
   BenchmarkMethodExpression-8  1000000000   0.8 ns/op   0 B/op
   BenchmarkMethodValue-8        500000000   2.5 ns/op   0 B/op
   ```

   **性能分析:**
   - **直接调用**: 最快,可能被内联
   - **Method Expression**: 接近直接调用,无闭包开销
   - **Method Value**: 最慢,有闭包间接调用开销

   **原因:**
   ```
   直接调用: p.Distance()
   asm: CALL (*Point).Distance(SB)

   Method Expression: f(p)
   asm: CALL (*Point).Distance(SB)

   Method Value: f()
   asm:
       MOV closure, DX       ; 加载闭包
       MOV 8(DX), AX         ; 获取接收者
       CALL *0(DX)           ; 间接调用
   ```

3. **包装方法生成**

   **答案:**

   ```go
   package main

   import (
       "fmt"
       "reflect"
   )

   // 为值接收者方法生成指针接收者包装
   func generateWrapper(typ reflect.Type, methodName string) interface{} {
       // 获取值类型的方法
       method, ok := typ.MethodByName(methodName)
       if !ok {
           panic("方法不存在")
       }

       // 创建包装函数
       ptrType := reflect.PtrTo(typ)

       wrapper := func(args []reflect.Value) []reflect.Value {
           // args[0]是*T类型的接收者
           receiver := args[0]

           // 检查nil
           if receiver.IsNil() {
               panic("nil pointer dereference")
           }

           // 解引用得到T类型的值
           value := receiver.Elem()

           // 调用原方法
           methodValue := value.Method(method.Index)
           return methodValue.Call(args[1:])
       }

       // 构造函数类型
       inTypes := []reflect.Type{ptrType}
       for i := 1; i < method.Type.NumIn(); i++ {
           inTypes = append(inTypes, method.Type.In(i))
       }

       outTypes := []reflect.Type{}
       for i := 0; i < method.Type.NumOut(); i++ {
           outTypes = append(outTypes, method.Type.Out(i))
       }

       funcType := reflect.FuncOf(inTypes, outTypes, false)

       return reflect.MakeFunc(funcType, wrapper).Interface()
   }

   // 测试
   type Point struct {
       x float64
   }

   func (p Point) Get() float64 {
       return p.x
   }

   func main() {
       typ := reflect.TypeOf(Point{})
       wrapper := generateWrapper(typ, "Get")

       // 使用包装方法
       wrapperFunc := wrapper.(func(*Point) float64)
       p := &Point{x: 10}
       result := wrapperFunc(p)
       fmt.Println(result)  // 输出: 10
   }
   ```

4. **继承链分析**

   **答案:**

   ```go
   package main

   import (
       "fmt"
       "reflect"
   )

   type A struct {
       a int
   }

   func (a A) MethodA() {}

   type B struct {
       A
       b int
   }

   func (b B) MethodB() {}

   type C struct {
       B
       c int
   }

   func (c C) MethodC() {}

   func analyzeEmbedding(typ reflect.Type, indent string) {
       fmt.Printf("%sType: %s\n", indent, typ.Name())

       // 打印方法
       fmt.Printf("%sMethods:\n", indent)
       for i := 0; i < typ.NumMethod(); i++ {
           method := typ.Method(i)
           fmt.Printf("%s  - %s\n", indent, method.Name)
       }

       // 遍历嵌入字段
       for i := 0; i < typ.NumField(); i++ {
           field := typ.Field(i)
           if field.Anonymous {  // 嵌入字段
               fmt.Printf("%sEmbedded: %s\n", indent, field.Name)
               analyzeEmbedding(field.Type, indent+"  ")
           }
       }
   }

   func main() {
       cType := reflect.TypeOf(C{})
       analyzeEmbedding(cType, "")
   }
   ```

   **输出:**
   ```
   Type: C
   Methods:
     - MethodA
     - MethodB
     - MethodC
   Embedded: B
     Type: B
     Methods:
       - MethodA
       - MethodB
     Embedded: A
       Type: A
       Methods:
         - MethodA
   ```

5. **方法覆盖**

   **答案:**

   ```go
   package main

   import "fmt"

   type Base struct{}

   func (b Base) Process() string {
       return "base"
   }

   type Derived struct {
       Base
   }

   func (d Derived) Process() string {
       return "derived: " + d.Base.Process()
   }

   func main() {
       d := Derived{}

       // 测试1: 直接调用
       fmt.Println(d.Process())        // derived: base

       // 测试2: 调用基类方法
       fmt.Println(d.Base.Process())   // base

       // 测试3: 通过接口
       type Processor interface {
           Process() string
       }

       var p Processor = d
       fmt.Println(p.Process())        // derived: base
   }
   ```

   **覆盖规则:**
   - Go支持方法覆盖
   - 同名方法隐藏嵌入字段的方法
   - 可通过字段名显式调用基类方法
   - 接口调用使用外层方法

### 四、综合应用题答案

1. **接口实现**

   **答案:**

   ```go
   type Reader interface {
       Read() string
   }

   type File struct {
       content string
   }

   func (f File) Read() string {
       return f.content
   }

   func main() {
       var r Reader = File{"hello"}   // ✓ 能编译通过
       var r Reader = &File{"hello"}  // ✓ 也能编译通过
   }
   ```

   **为什么两种都可以?**

   **值类型赋值给接口:**
   ```go
   var r Reader = File{"hello"}
   ```
   - File有Read方法(值接收者)
   - File实现了Reader接口
   - 直接装箱

   **指针类型赋值给接口:**
   ```go
   var r Reader = &File{"hello"}
   ```
   - *File的方法集包含:
     - (*File).Read (包装方法)
   - 编译器为File.Read生成了(*File).Read包装方法
   - *File也实现了Reader接口

   **方法集规则与接口:**

   ```
   接口要求: Read() string

   File的方法集:
   - File.Read() string       ✓ 满足

   *File的方法集:
   - File.Read() string       ✓ 通过包装
   - (*File).Read() string    ✓ 包装方法
   ```

   **反例(不能编译):**

   ```go
   type Writer interface {
       Write(string)
   }

   type File struct {
       content string
   }

   func (f *File) Write(s string) {
       f.content = s
   }

   func main() {
       var w Writer = File{}  // ✗ 编译错误!
       // File没有Write方法,只有*File有

       var w Writer = &File{} // ✓ 正确
   }
   ```

2. **方法表**

   **答案:**

   **方法表生成:**

   ```go
   type T struct {
       value int
   }

   func (t T) ValueMethod() {}
   func (t *T) PointerMethod() {}
   ```

   **T的方法表:**
   ```
   T.methods:
   ┌────────────────┐
   │ ValueMethod    │ → T.ValueMethod
   └────────────────┘
   ```

   **T的方法表:**
   ```
   *T.methods:
   ┌────────────────┐
   │ PointerMethod  │ → (*T).PointerMethod
   ├────────────────┤
   │ ValueMethod    │ → (*T).ValueMethod (包装)
   └────────────────┘
   ```

   **接口itab:**

   ```go
   type Reader interface {
       Read() string
   }

   var r Reader = &File{}
   ```

   **itab结构:**
   ```
   itab for (*File, Reader):
   ┌────────────────┐
   │ interface type │ → Reader类型信息
   ├────────────────┤
   │ concrete type  │ → *File类型信息
   ├────────────────┤
   │ hash           │  类型哈希
   ├────────────────┤
   │ fun[0]         │ → (*File).Read方法指针
   └────────────────┘
   ```

   **方法表vs itab:**
   - 方法表: 编译时生成,包含类型所有方法
   - itab: 运行时生成,只包含接口需要的方法
   - itab缓存在全局map中

3. **嵌入字段的方法提升**

   **答案:**

   ```go
   type Inner struct {
       value int
   }

   func (i Inner) String() string {
       return fmt.Sprintf("%d", i.value)
   }

   type Outer struct {
       Inner
       name string
   }

   func main() {
       o := Outer{Inner{10}, "test"}
       fmt.Println(o)  // 调用哪个String方法?
   }
   ```

   **查找过程:**

   1. **fmt.Println查找Stringer接口:**
      ```go
      type Stringer interface {
          String() string
      }
      ```

   2. **检查Outer是否实现Stringer:**
      - 检查Outer.String()方法 → 没有
      - 检查嵌入字段的方法 → Inner.String() ✓

   3. **编译器生成包装方法:**
      ```go
      func (o Outer) String() string {
          return o.Inner.String()
      }
      ```

   4. **调用:**
      ```
      fmt.Println(o)
        ↓
      o.String()
        ↓
      o.Inner.String()
        ↓
      输出: "10"
      ```

   **如果Outer也有String方法:**

   ```go
   func (o Outer) String() string {
       return o.name + ": " + o.Inner.String()
   }

   func main() {
       o := Outer{Inner{10}, "test"}
       fmt.Println(o)  // 输出: "test: 10"
       // 调用Outer.String,覆盖了Inner.String
   }
   ```

4. **方法值的逃逸**

   **答案:**

   ```go
   type Counter struct {
       count int
   }

   func (c *Counter) Inc() {
       c.count++
   }

   func getInc(c *Counter) func() {
       return c.Inc
   }
   ```

   **逃逸分析:**

   ```bash
   go build -gcflags="-m" test.go

   # 输出:
   # ./test.go:9: c.Inc escapes to heap
   # ./test.go:9: leaking param: c
   ```

   **内存分配:**

   ```
   栈上(调用者):
   ┌────────────────┐
   │  c *Counter    │ → 可能在栈也可能在堆
   └────────────────┘

   堆上:
   ┌────────────────┐
   │  funcval       │  方法值对象
   ├────────────────┤
   │  fn指针        │ → Inc包装函数
   ├────────────────┤
   │  c指针         │ → Counter对象
   └────────────────┘
         ↓
   ┌────────────────┐
   │  Counter       │  如果c逃逸,分配在堆
   ├────────────────┤
   │  count int     │
   └────────────────┘
   ```

   **逃逸原因:**
   - c.Inc创建了闭包
   - 闭包捕获了c
   - 闭包可能在函数返回后调用
   - c必须逃逸到堆

   **避免逃逸:**

   ```go
   // 方案1: 不返回方法值
   func callInc(c *Counter) {
       c.Inc()  // c不逃逸
   }

   // 方案2: 返回Method Expression
   func getIncExpr() func(*Counter) {
       return (*Counter).Inc  // 无闭包,无逃逸
   }
   ```

5. **组合vs接口**

   **答案:**

   **特性对比:**

   | 特性 | 组合式继承 | 接口 |
   |------|-----------|------|
   | **代码复用** | ✓✓ 直接继承实现 | ✗ 需要重新实现 |
   | **类型安全** | ✓ 编译时检查 | ✓ 编译时检查 |
   | **性能** | ✓✓ 无虚表开销 | ✓ 有itab查找开销 |
   | **灵活性** | ✗ 结构固定 | ✓✓ 任意类型实现 |
   | **解耦** | ✗ 强耦合 | ✓✓ 完全解耦 |
   | **多态** | ✗ 无动态多态 | ✓✓ 动态多态 |
   | **测试** | ✗ 难以mock | ✓✓ 易于mock |

   **选择组合的场景:**

   1. **代码复用为主:**
      ```go
      type FileLogger struct {
          File  // 复用File的所有方法
      }
      ```

   2. **has-a关系:**
      ```go
      type Car struct {
          Engine  // 汽车有引擎
          Wheel
      }
      ```

   3. **扩展第三方类型:**
      ```go
      type MyInt struct {
          int  // 无法继承int,但可以嵌入
      }
      ```

   **选择接口的场景:**

   1. **依赖注入:**
      ```go
      type Service struct {
          db Database  // interface
      }
      ```

   2. **插件系统:**
      ```go
      type Plugin interface {
          Execute()
      }
      ```

   3. **测试mock:**
      ```go
      type UserRepo interface {
          GetUser(id int) *User
      }

      type MockUserRepo struct{}  // 测试用
      ```

   4. **抽象行为:**
      ```go
      type Sorter interface {
          Len() int
          Less(i, j int) bool
          Swap(i, j int)
      }
      ```

   **最佳实践:**

   ```go
   // 组合用于实现,接口用于抽象

   // 1. 内部使用组合
   type BaseHandler struct {
       logger *Logger
       db     *Database
   }

   type UserHandler struct {
       BaseHandler  // 组合复用
   }

   // 2. 对外暴露接口
   type Handler interface {
       ServeHTTP(w http.ResponseWriter, r *http.Request)
   }

   // 3. 依赖接口而非实现
   func NewServer(h Handler) *Server {
       return &Server{handler: h}
   }
   ```

---

## 学习建议

1. **理解方法本质**: 方法就是带接收者参数的函数
2. **掌握包装机制**: 理解包装方法的生成和作用
3. **方法集规则**: 熟记T和*T的方法集差异
4. **接口实现**: 理解方法集与接口实现的关系
5. **性能意识**: 了解不同调用方式的开销
6. **组合优于继承**: 灵活使用组合和接口

## 扩展阅读

- Go语言规范: Method sets
- Go Blog: Go Data Structures: Interfaces
- Effective Go: Embedding
- 《Go语言设计与实现》方法章节


第 2 章
指针
指针凭借其灵活强大的内存操作能力，在C和C++中扮演着非常重要的角色，但也因一些常见的安
全问题给人们带来很多困扰。指针在Go语言中被保留了下来，但是影响力似乎大大降低了，出于
安全方面的考虑，指针运算等一些重要特性被移除，使指针显得不再那么重要。在学习过程中，有
很多人对值类型、指针或引用类型，以及值和地址这些概念感到困惑。本章从指针的构成出发，首
先理解指针的本质，然后逐一分析指针的常见操作的实现原理，以及常见的问题和解决方法，最后
介绍关于Go语言unsafe包的一些思考和实践。

2.1 指针构成
在Go语言中，声明一个指针变量的示例代码如下：

变量名为p，其中的int为变量的类型。对int进一步拆解，*表明了p是一个指针变量，用来存储一
个地址，而int是指针的元素类型，也就是当p中存了一个有效地址的时候，该地址处的内存会被解
释为int类型。

无论指针的元素类型是什么，指针变量本身的格式都是一致的，即一个无符号整型，变量大小能够
容纳当前平台的地址。例如在 386 架构上是一个 32 位无符号整型，在amd64架构上是一个 64 位无符
号整型。

有着不同元素类型的指针被视为不同类型，这是语言设计层面强加的一层安全限制，因为不同的元
素类型会使编译器对同一个内存地址进行不同的解释。

2.1.1 地址
在Go语言中，一个有效的地址就是一个无符号整型数值，运行阶段用来在进程的内存地址空间中
确定一个位置。

在第 1 章中简单地介绍了x86的几种常用寻址方式，指针一般会用到基址+位移的寻址方式。例如当
指针元素的类型为int时，通过指针访问int元素的代码被编译成汇编指令，就是将某个通用寄存器
用作基址进行寻址。

在amd64架构下通过go build命令编译一个示例，代码如下：

使用Go自带的objdump工具反编译main.read（）函数，得到的汇编代码如下：

在第一条MOVQ指令中，第 1 个操作数0x8（SP）表示参数p在栈上的地址，关于函数栈帧布局，将
会在第 3 章中详细介绍，目前只要理解这条指令的作用是把参数p中存储的地址值复制到AX寄存器
中即可。

在第二条MOVQ指令中，第 1 个操作数使用AX作为基址加上位移 0 ，也就是用基址+位移的方式寻
址指针p指向的数据，所以这条指令的作用就是把目标地址处的值复制到AX中。

在第三条MOVQ指令中，第 2 个操作数0x10（SP）表示栈上返回值的地址，所以这条指令的作用就
是把AX中存储的值复制到返回值v中。

经过上面三条指令，便可成功地把指针p指向的数据复制到函数返回值空间。

2.1.2 元素类型
指针本身就是个无符号整型，这一点不会因不同的元素类型而有所不同，而元素类型会影响编译器
如何对指针中存储的地址进行解释，这一点也可以通过汇编代码进行验证。
把第 2 章/code_2_1.go中read（）函数修改为read32（）函数，其主要目的是改变参数和返回值的类
型，代码如下：

修改后的代码重新进行编译和反编译，得到的汇编代码如下：
可以看到第一条用于复制指针存储的地址的指令没有发生变化。第二条指令中的内存寻址单元
0 （AX）也没有变，而原本后两条MOVQ指令现在变成了MOVL，表明复制的数据长度发生了变
化，从 8 字节变成了 4 字节。造成这一变化的原因正是指针元素类型从int变成了int32。

2.2 相关操作
本节分析指针常见操作及其底层实现原理，也会介绍指针所引发的那些广受诟病的问题，以及在
Go语言中如何解决这些问题。此外，一些指针特性受限于安全问题，在Go语言中不能直接使用，
在本节也会探讨一些替代方案及背后的思考。

2.2.1 取地址
指针中存储的是地址，而地址一般通过取地址运算符获得，或者在动态分配内存时由new之类的函
数返回。在Go语言中取地址运算符与C语言相比似乎没什么变化，编译器会确保应用取地址运算符
的变量类型与指针的元素类型是一致的。下面仍然通过反编译一个简单的函数，来看一下取地址运
算符到底做了什么。

在amd64架构下通过go build命令编译一个示例，代码如下：

反编译main.addr（）函数得到的代码如下：

其中LEAQ指令的作用就是取得main.n的地址并装入AX寄存器中。后面的MOVQ指令则把AX的值
复制到返回值p。

这里获取的是一个包级别变量n的地址，等价于C语言的全局变量，变量n的地址是在编译阶段静态
分配的，所以LEAQ指令通过位移寻址的方式得到了main.n的地址。LEAQ同样也支持基于基址和
索引获取地址，具体可参考第 1 章所介绍的x86寻址方式。

在C语言中，不应该将函数内某个局部变量的地址作为返回值返回，虽然编译器允许这样的代码通
过编译，但在代码逻辑上却属于明显的Bug。因为函数一旦返回，栈帧随即销毁，这部分内存会被
后续的函数栈帧覆盖，所以通过返回的指针读写栈上的数据就可能会造成程序异常崩溃，虽然也有
可能不会崩溃，但是基于错误的数据继续运行下去，会变得更加难以调试和排查。

在Go语言中，通过逃逸分析机制避免了此类问题。来看一个示例，代码如下：

其中变量n实际上是在堆上分配的，因为n逃逸到堆上，所以即使newInt（）函数返回，函数栈帧销
毁，也不会影响后续正常使用n的指针。待到第 3 章介绍函数时再进一步介绍逃逸。

2.2.2 解引用
通过指针中的地址去访问原来的变量，就是所谓的指针解引用。在2.1.1节已经通过反编译验证了指
针的解引用过程，就是把地址存入某个通用寄存器，然后用作基址进行寻址。接下来就介绍一下C
语言中与指针解引用相关的几个常见问题，以及这些问题在Go语言中是如何解决的。

1 ．空指针异常

所谓空指针，就是地址值为 0 的指针。按照操作系统的内存管理设计，进程地址空间中地址为 0 的内
存页面不会被分配和映射，保留地址 0 在程序代码中用作无效指针判断，所以对空指针进行解引用
操作就会造成程序异常崩溃，程序代码在对指针进行解引用前，始终要确保指针非空，因而需要添
加必要的判断逻辑。

所以遭遇空指针异常并非语言设计方面的缺陷，而是程序逻辑上的Bug。Go语言中对空指针进行解
引用会造成程序panic（宕机）。

2 ．野指针问题

野指针问题一般是由于指针变量未初始化造成的。众所周知，C语言中声明的变量需要显式地初始
化，否则就是内存中上次遗留的随机值。对于未初始化的指针变量而言，如果内存中的随机值非
零，就会使指针指向一个随机的内存地址，而且会绕过代码中的空指针判断逻辑，从而造成内存访
问错误。

为了解决C语言变量默认不初始化带来的各种问题，Go语言中声明的变量默认都会初始化为对应类
型的零值，指针类型变量都会初始化为nil，而代码中的空指针判断逻辑能够避免空指针异常，从
而使问题得到解决。

3 ．悬挂指针问题

在C语言中，程序员需要手动分配和释放内存，而所谓悬挂指针问题，就是指程序过早地释放了内
存，而后续代码又对已经释放的内存进行访问，从而造成程序出现错误或异常。

Go语言实现了自动内存管理，由GC负责释放堆内存对象。GC基于标记清除算法进行对象的存活分
析，只有明确不可达的对象才会被释放，因此悬挂指针问题不复存在。

2.2.3 强制类型转换
基于指针的强制类型转换非常高效，因为不会生成任何多余的指令，也不会额外分配内存，只是让
编译器换了一种方式来解释内存中的数据。出于安全方面的考虑，Go语言不建议频繁地进行指针
强制类型转换。两种不同类型指针间的转换需要用unsafe.Pointer作为中间类型，unsafe.Pointer可以
和任意一种指针类型互相转换。

在amd64架构下反编译一个函数，代码如下：

得到汇编代码如下：
把指针的类型强转换为int32后，原本的MOVQ指令变成了MOVL，没有产生任何额外指令，所以
转换效率是非常高的。

2.2.4 指针运算
在C语言中，指针和不指定长度的数组，在元素类型相同的情况下是可以等价使用的，指针加上一
个整数n等价于取数组中下标为n的元素的地址。指针可以进行加减运算，给操作多维数组带来了很
大方便，但也经常会造成内存访问越界问题。

Go语言中的数组必须指定长度，并且是值类型，与指针不再等价，指针运算也不再支持，这些都
是出于安全考虑的。数组的长度在编译时期能够确定，编译器可以生成代码检测下标越界问题，而
指针则不然，编译器无法确定指针运算的安全边界，所以无法保证其安全性。

Go语言的slice集成了数组和指针的优点，既能像指针那样关联一个可以动态增长的Buffer，又能像
数组那样让编译器生成下标越界检测代码，在某些场合可以考虑用slice代替指针运算。

如果还想像C语言中那样直接进行指针运算，就需要借助unsafe.Pointer进行转换。2.2.3节中已经提
到unsafe.Pointer可以与任何一种指针类型互相转换，除此之外unsafe.Pointer还可以与uintptr互相转
换，而后者可以进行整数运算。

假如有一个元素类型为int的指针p，要把p移动到下一个int的位置，在C语言中可以通过指针的自增
运算实现，代码如下：

在Go语言中等价的代码如下：

在Go语言中实现此功能就显得有些烦琐了，先把p转换为unsafe.Pointer类型，再进一步转换为
uintptr类型，然后加上一个int的大小，再转换回unsafe.Pointer类型，最终转换为*int类型。

2.3 unsafe 包
本节简单地介绍Go语言的unsafe包，在2.2节中已经用到了unsafe.Pointer进行指针的强制类型转换和
指针运算，实际上就是人为地干预编译器对内存地址的解释方式，这些能力对于研究语言的底层实
现来讲是不可或缺的。

代码中用好unsafe，能够优化程序的性能，想必很多人都见过经典的类型转换，代码如下：

Slice Header结构只是比String Header结构多了一个容量字段，相当于内嵌了一个String Header，如
图2-1所示。

图2-1 String Header和Slice Header的结构

用这种强制类型转换的方式可以避免额外的内存分配，从而减少程序的开销，但是也会带来一些风
险。因为按照Go语言的设计思想，string的内容是不可修改的，但是slice元素是可以修改的，基于
上述方法得到的string与原来的slice共享底层Buffer，如果不经意修改了slice就可能会造成程序逻辑
错误。

根据官方文档的说法，unsafe包包含的操作绕过了Go语言的类型安全机制，使用unsafe包会造成程
序不可移植，并且不受Go 1兼容性准则的保护。那么unsafe到底该不该用呢？本节就围绕这个问题
进行一些分析研究。

2.3.1 标准库与 keyword

本节主要分析unsafe包的本质，到底是标准库还是一组keyword。这个思考源于2.2.4节进行指针运
算时用到的unsafe.Sizeof，而sizeof在C语言中是个关键字。先从源码入手，梳理unsafe包都提供了
些什么，代码如下：

根据源码中的注释，ArbitraryType在这里只是用于文档目的，实际上并不属于unsafe包，它可以表
示任意的Go表达式类型。Sizeof（）函数用来返回任意类型的大小，Offsetof（）函数用来返回任
意结构体类型的某个字段在结构体内的偏移，而Alignof（）函数用来返回任意类型的对齐边界，
最重要的是这 3 个函数的返回值都是常量。

基于上述信息，已经可以断定unsafe并不是一个真实的包，unsafe提供的这些能力不是标准库层面
能够实现的。指针强制类型转换本来就是在编译阶段实现的，而Sizeof（）函数、Offsetof（）函数
和Alignof（）函数返回的是常量值，也就要求返回值必须在编译阶段确定，所以必须由编译器直
接支持。可以通过实验进行验证，代码如下：

在amd64平台，反编译size（）函数得到汇编代码如下：

这条MOVQ指令直接向返回值o中写入了立即数 8 ，也就说明Sizeof（）函数在编译阶段就被转换成
了立即数，与C语言中的sizeof并无区别。上述测试方法同样适用于Offsetof（）函数和Alignof（）
函数。

既然这些都是由编译器直接支持的，本质上跟keyword一样，为什么Go语言要放到unsafe包中呢？
根本原因还是出于安全考虑。直接的任意操作内存的能力可以让程序员写出更高效的代码，但是也
因为过于灵活而让编译器无法落实安全检查，从而使程序变得不安全。unsafe这个名字就旨在提醒
程序员，内存操作有风险，要谨慎！

2.3.2 关于 uintptr

很多人都认为uintptr是个指针，其实不然。不要对这个名字感到疑惑，它只不过是个uint，大小与
当前平台的指针宽度一致。因为unsafe.Pointer可以跟uintptr互相转换，所以Go语言中可以把指针转
换为uintptr进行数值运算，然后转换回原类型，以此来模拟C语言中的指针运算。

需要注意的是，不要用uintptr来存储堆上对象的地址。具体原因和GC有关，GC在标记对象的时候
会跟踪指针类型，而uintptr不属于指针，所以会被GC忽略，造成堆上的对象被认为不可达，进而
被释放。用unsafe.Pointer就不会存在这个问题了，unsafe.Pointer类似于C语言中的void*，虽然未指
定元素类型，但是本身类型就是个指针。

2.3.3 内存对齐
硬件的实现一般会将内存的读写对齐到数据总线的宽度，这样既可以降低硬件实现的复杂度，又可
以提升传输的效率。有些硬件平台允许访问未对齐的地址，但是会带来额外的开销，而有的硬件平
台不支持访问未对齐的地址，当遇到未对齐的地址时会直接抛出异常。鉴于这些原因，编译器在定
义数据类型时，还有runtime在分配内存时，都要进行对齐操作。

Go语言的内存对齐规则参考了两方面因素：一是数据类型自身的大小，复合类型会参考最大成员
大小；二是硬件平台机器字长。

机器字长是指计算机进行一次整数运算所能处理的二进制数据的位数，在x86平台可以理解成数据
总线的宽度。当数据类型自身大小小于机器字长时，会被对齐到自身大小的整数倍；当自身大小大
于机器字长时，会被对齐到机器字长的整数倍。

通过unsafe.Sizeof（）函数和unsafe.Alignof（）函数可以得到目标数据类型的大小和对齐边界，表
2-1给出了常见内置类型的大小和对齐边界。

表2-1 常见内置类型的大小和对齐边界

complex类型由实部和虚部两个float组成，complex64相当于[2]float32，complex128相当于
[2]float64，所以对齐边界分别与float32、float64一致。

map多数情况下会被分配在堆上，本地只有一个指针指向堆上的数据结构，而指针的对齐边界自然
与uintptr相同。

string和slice的结构定义可参考reflect.StringHeader与reflect.SliceHeader，代码如下：

它们的对齐边界与其最大的成员，即类型uintptr的对齐边界相同。值得强调的是对于struct而言，每
个成员都会以结构体的起始地址为基地址，按自身类型的对齐边界对齐。除此之外，整个struct还

要按照成员中最大的对齐边界进行对齐，所以编译器会按需要在结构体相邻成员之间及最后一个成
员之后添加padding，因此需要合理地排列数据成员的顺序，从而使整个struct的空间占用最小化。

来看一个示例，代码如下：

数据类型s1在amd64架构上占用了 32 字节空间，如图2-2所示，在a和b之间有 7 字节的padding，目的
是让成员b对齐到 8 。c和d之间有 3 字节的padding，为的是让成员d对齐到 4 。又因为整个struct的成员
中最大的对齐边界为int64对应的 8 ，所以e之后还有 6 字节的padding，使整个结构体对齐到 8 ，但是
这样总共浪费了 16 字节空间，空间利用率只有50%。

图2-2 s1内存布局

接下来通过调整结构体成员的位置，尽量避免编译器添加padding，调整后的代码如下：

如图2-3所示，数据类型s2和之前的s1有着相同类型的 5 个数据成员，但是经过人为优化成员的顺序
后，编译器没有添加任何padding，整个struct占用了 16 字节空间，利用率达到100%。

图2-3 s2内存布局

2.4 本章小结
本章首先从指针的构成开始讲解，通过反汇编的方式，展示了编译器如何使用指针存储的地址进行
内存寻址，以及元素类型对指令生成的影响。后续又介绍了与指针相关的操作、常见问题和解决方
法。最后结合指针强制类型转换的实例介绍了unsafe包，并通过unsafe的实际应用，了解了内存对
齐的原理。在接下来对Go语言特性的探索中，unsafe也会起到非常重要的作用。

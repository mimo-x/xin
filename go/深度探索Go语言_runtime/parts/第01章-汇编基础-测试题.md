# 第1章 汇编基础 - 读后测试题

## 第一部分:问题

### 一、概念理解题

1. **x86_64架构通用寄存器**
   - 列举x86_64架构下有哪些通用寄存器?它们如何向前兼容32位寄存器?
   - 哪些寄存器可以进一步拆分成8位寄存器?请画出EAX寄存器的结构图。

2. **寄存器的特殊用途**
   - ESP、EBP、EIP三个寄存器各自的作用是什么?
   - 为什么EIP寄存器不能在汇编代码中直接引用?

3. **内存寻址方式**
   - x86架构支持哪几种内存寻址方式?
   - 什么是基址+位移+索引×比例系数的寻址方式?请举例说明。

4. **内存分页机制**
   - 简述x86_64架构下的四级页表机制及各级页表的作用
   - 为什么说64位架构实际上只使用了48位地址?
   - TLB的作用是什么?为什么切换进程会导致TLB失效?

5. **汇编指令**
   - ADD和SUB指令对操作数有什么要求?
   - MOV指令有哪些常见的使用场景?
   - CALL和RET指令是如何配合实现函数调用的?

### 二、代码分析题

1. **寄存器操作**
   ```asm
   MOV EAX, 0x12345678
   MOV BL, AL
   MOV CX, AX
   ```
   执行以上指令后,BL和CX寄存器中的值分别是多少?(用十六进制表示)

2. **内存寻址**
   ```asm
   MOV EAX, [EBX + ECX*4 + 8]
   ```
   假设EBX=0x1000, ECX=0x10, 请问这条指令访问的内存地址是多少?

3. **栈操作**
   ```asm
   PUSH EAX
   PUSH EBX
   POP ECX
   POP EDX
   ```
   执行前EAX=1, EBX=2, 执行后ECX和EDX的值分别是多少?

### 三、实践题

1. **汇编代码转换**
   将以下Go代码转换为等价的汇编伪代码:
   ```go
   func add(a, b int) int {
       return a + b
   }
   ```

2. **内存布局分析**
   给定以下Go代码:
   ```go
   type Point struct {
       x int64
       y int64
   }

   func main() {
       p := Point{x: 10, y: 20}
       // 请描述p在内存中的布局
   }
   ```

3. **地址计算**
   在64位Linux系统中,进程的虚拟地址0x7fff_ffff_f000经过四级页表转换,请说明:
   - 如何从这个地址中提取各级页表索引?
   - 页内偏移是多少?

### 四、综合应用题

1. **性能优化**
   为什么在访问数组元素时,顺序访问比随机访问快?请从内存分页和缓存的角度解释。

2. **调试分析**
   你在使用GDB调试程序时,如何查看:
   - 当前函数的栈帧?
   - 某个变量在哪个寄存器中?
   - 当前指令指针的位置?

3. **汇编风格对比**
   Go语言的汇编采用Plan 9汇编风格,与Intel风格有何主要区别?请列举至少3个不同点。

---

## 第二部分:答案与解析

### 一、概念理解题答案

1. **x86_64架构通用寄存器**

   **答案:**
   - x86_64有16个通用寄存器:RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP, R8-R15
   - 前8个寄存器向前兼容:RAX的低32位是EAX,EAX的低16位是AX,AX又分为高8位AH和低8位AL
   - 只有RAX, RBX, RCX, RDX可以拆分成8位的寄存器(AH/AL, BH/BL, CH/CL, DH/DL)

   **EAX寄存器结构图:**
   ```
   RAX (64位): [────────────────────────────────────────────────────────────────]
   EAX (32位):                                 [────────────────────────────────]
   AX  (16位):                                                 [────────────────]
   AH/AL(8位):                                                 [────────][──────]
   ```

2. **寄存器的特殊用途**

   **答案:**
   - **ESP(RSP)**: 扩展栈指针寄存器,指向当前栈顶,用于栈的管理
   - **EBP(RBP)**: 扩展帧指针寄存器,指向当前栈帧的基址,用于访问函数参数和局部变量
   - **EIP(RIP)**: 指令指针寄存器,存储下一条将要执行的指令的地址
   - EIP不能直接引用是因为CPU的设计,只能通过跳转、CALL、RET等指令间接修改其值,这是为了保证程序流程的安全性和可控性

3. **内存寻址方式**

   **答案:**
   - **直接寻址**: `MOV EAX, [0x12345678]`
   - **寄存器间接寻址**: `MOV EAX, [EBX]`
   - **寄存器+位移**: `MOV EAX, [EBX + 8]`
   - **基址+索引**: `MOV EAX, [EBX + ECX]`
   - **基址+索引×比例**: `MOV EAX, [EBX + ECX*4]`
   - **完整形式**: `MOV EAX, [EBX + ECX*4 + 8]`

   **示例:** 访问数组元素 `arr[i]`
   ```asm
   ; 假设EBX存储数组基址,ECX存储索引i,每个元素4字节
   MOV EAX, [EBX + ECX*4]
   ```

4. **内存分页机制**

   **答案:**
   - **四级页表结构:**
     - PML4 (Page Map Level 4): 最高级页表
     - PDP (Page Directory Pointer): 页目录指针表
     - PD (Page Directory): 页目录表
     - PT (Page Table): 页表
     - 每级使用9位索引,页内偏移12位

   - **48位地址限制:** 虽然寄存器是64位,但当前硬件只实现了48位地址线,高16位必须与第47位相同(符号扩展),这样可以节省硬件成本,48位已经可以寻址256TB内存,目前已经足够

   - **TLB作用:** Translation Lookaside Buffer,缓存虚拟地址到物理地址的映射,避免每次都查询页表。切换进程时因为页表不同,TLB缓存的映射失效,需要重新建立

5. **汇编指令**

   **答案:**
   - **ADD/SUB操作数要求:**
     - 源操作数可以是:寄存器、内存、立即数
     - 目的操作数必须可写:寄存器或内存
     - 两个操作数不能同时为内存
     - 例: `ADD EAX, 10` ✓  `ADD [EBX], [ECX]` ✗

   - **MOV使用场景:**
     - 寄存器间数据传输: `MOV EAX, EBX`
     - 立即数加载: `MOV EAX, 100`
     - 内存读取: `MOV EAX, [0x1000]`
     - 内存写入: `MOV [0x1000], EAX`

   - **CALL/RET配合:**
     - CALL指令: ①将下一条指令地址压栈 ②跳转到目标函数
     - RET指令: ①从栈中弹出返回地址 ②跳转到该地址继续执行

### 二、代码分析题答案

1. **寄存器操作**

   **答案:**
   ```
   初始: EAX = 0x12345678
   MOV BL, AL  → BL = 0x78 (AL是EAX的低8位)
   MOV CX, AX  → CX = 0x5678 (AX是EAX的低16位)
   ```

2. **内存寻址**

   **答案:**
   ```
   地址 = EBX + ECX*4 + 8
        = 0x1000 + 0x10*4 + 8
        = 0x1000 + 0x40 + 8
        = 0x1048
   ```

3. **栈操作**

   **答案:**
   ```
   栈的生长方向是从高地址向低地址

   初始: EAX=1, EBX=2, 栈: []
   PUSH EAX  → 栈: [1]
   PUSH EBX  → 栈: [1, 2]  (栈顶是2)
   POP ECX   → ECX=2, 栈: [1]
   POP EDX   → EDX=1, 栈: []

   结果: ECX=2, EDX=1
   ```

### 三、实践题答案

1. **汇编代码转换**

   **答案:**
   ```asm
   ; Intel风格伪代码
   ; 参数通过栈传递,返回值通过EAX返回
   add:
       MOV EAX, [ESP + 8]   ; 加载参数a
       ADD EAX, [ESP + 12]  ; 加上参数b
       RET                  ; 返回,结果在EAX中
   ```

2. **内存布局分析**

   **答案:**
   ```
   Point结构体在内存中的布局(假设在栈上分配):

   高地址
   ┌──────────────┐
   │   y = 20     │  +8字节  (int64)
   ├──────────────┤
   │   x = 10     │  +0字节  (int64)
   └──────────────┘
   低地址

   - Point占用16字节
   - 字段按声明顺序排列
   - 在64位系统中,int64对齐到8字节边界
   ```

3. **地址计算**

   **答案:**
   ```
   虚拟地址: 0x7fff_ffff_f000 (二进制48位有效)

   地址分解 (从高到低):
   - PML4索引 (bits 47-39): 9位
   - PDP索引  (bits 38-30): 9位
   - PD索引   (bits 29-21): 9位
   - PT索引   (bits 20-12): 9位
   - 页内偏移 (bits 11-0):  12位 = 0x000

   0x7fff_ffff_f000 = 0111_1111_1111_1111_1111_1111_1111_1111_1111_0000_0000_0000

   PML4索引 = 0xFF (255)
   PDP索引  = 0x1FF (511)
   PD索引   = 0x1FF (511)
   PT索引   = 0x1FF (511)
   页内偏移 = 0x000 (0)
   ```

### 四、综合应用题答案

1. **性能优化**

   **答案:**
   顺序访问比随机访问快的原因:

   - **空间局部性原理**: 顺序访问的数据在内存中是连续的,一次加载一个页面(4KB)可以满足后续多次访问

   - **CPU缓存**: 现代CPU有多级缓存(L1/L2/L3),缓存行通常64字节,顺序访问可以充分利用已加载的缓存行

   - **预取机制**: CPU会预测访问模式,顺序访问时会自动预取后续数据到缓存

   - **TLB命中率**: 顺序访问同一页面内的数据时,TLB只需查询一次,随机访问可能频繁miss

   **性能差异示例:**
   ```go
   // 顺序访问 - 快
   for i := 0; i < len(arr); i++ {
       sum += arr[i]
   }

   // 随机访问 - 慢
   for i := 0; i < len(arr); i++ {
       sum += arr[rand.Intn(len(arr))]
   }
   ```

2. **调试分析**

   **答案:**
   ```bash
   # 查看当前栈帧
   (gdb) info frame
   (gdb) bt  # backtrace查看调用栈

   # 查看寄存器
   (gdb) info registers
   (gdb) print $rax  # 查看特定寄存器

   # 查看变量位置
   (gdb) info locals  # 局部变量
   (gdb) disassemble  # 反汇编当前函数
   (gdb) info symbol <address>  # 查看地址对应的符号

   # 查看指令指针
   (gdb) print $rip   # x86_64
   (gdb) print $pc    # 其他架构
   (gdb) x/i $rip     # 查看当前指令
   ```

3. **汇编风格对比**

   **答案:**

   | 特性 | Intel风格 | Plan 9(Go)风格 |
   |------|-----------|----------------|
   | 操作数顺序 | `MOV dest, src` | `MOVQ src, dest` |
   | 寄存器前缀 | 无前缀 `EAX` | 有前缀 `AX` (不加E/R) |
   | 立即数 | 直接写 `100` | 有$前缀 `$100` |
   | 内存寻址 | `[EAX+8]` | `8(AX)` |
   | 指令后缀 | 无或可选 | 必须 `MOVQ`(Q=Quad 8字节) |
   | 栈指针 | ESP/RSP | SP |
   | 帧指针 | EBP/RBP | FP (伪寄存器) |

   **示例对比:**
   ```asm
   ; Intel风格
   MOV EAX, [ESP + 8]
   ADD EAX, 10

   ; Plan 9风格
   MOVQ 8(SP), AX
   ADDQ $10, AX
   ```

---

## 学习建议

1. **实践为主**: 使用 `go build -gcflags="-S"` 查看Go代码生成的汇编
2. **对比学习**: 将简单的Go函数反汇编,理解编译器如何生成代码
3. **调试工具**: 熟练使用GDB/Delve进行底层调试
4. **阅读源码**: 研究Go runtime中的汇编实现,如 `runtime/asm_amd64.s`
5. **性能分析**: 使用pprof结合汇编分析性能瓶颈

## 扩展阅读

- Go语言官方文档: A Quick Guide to Go's Assembler
- Intel® 64 and IA-32 Architectures Software Developer Manuals
- 《程序员的自我修养—链接、装载与库》
- 《深入理解计算机系统》(CSAPP) 第3章
